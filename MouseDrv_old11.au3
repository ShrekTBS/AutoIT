#NoTrayIcon
FUNC _ARRAYADD(BYREF $AVARRAY,$VVALUE)
IF NOT ISARRAY($AVARRAY)THEN RETURN SETERROR(1,0,-1)
IF UBOUND($AVARRAY,0)<>1 THEN RETURN SETERROR(2,0,-1)
LOCAL $IUBOUND=UBOUND($AVARRAY)
REDIM $AVARRAY[$IUBOUND+1]
$AVARRAY[$IUBOUND]=$VVALUE
RETURN $IUBOUND
ENDFUNC
FUNC _ARRAYBINARYSEARCH(CONST BYREF $AVARRAY,$VVALUE,$ISTART=0,$IEND=0)
IF NOT ISARRAY($AVARRAY)THEN RETURN SETERROR(1,0,-1)
IF UBOUND($AVARRAY,0)<>1 THEN RETURN SETERROR(5,0,-1)
LOCAL $IUBOUND=UBOUND($AVARRAY)-1
IF $IUBOUND=-1 THEN RETURN SETERROR(6,0,-1)
IF $IEND<1 OR $IEND>$IUBOUND THEN $IEND=$IUBOUND
IF $ISTART<0 THEN $ISTART=0
IF $ISTART>$IEND THEN RETURN SETERROR(4,0,-1)
LOCAL $IMID=INT(($IEND+$ISTART)/2)
IF $AVARRAY[$ISTART]>$VVALUE OR $AVARRAY[$IEND]<$VVALUE THEN RETURN SETERROR(2,0,-1)
WHILE $ISTART<=$IMID AND $VVALUE<>$AVARRAY[$IMID]
IF $VVALUE<$AVARRAY[$IMID]THEN
$IEND=$IMID-1
ELSE
$ISTART=$IMID+1
ENDIF
$IMID=INT(($IEND+$ISTART)/2)
WEND
IF $ISTART>$IEND THEN RETURN SETERROR(3,0,-1)
RETURN $IMID
ENDFUNC
FUNC _ARRAYCOMBINATIONS(CONST BYREF $AVARRAY,$ISET,$SDELIM="")
IF NOT ISARRAY($AVARRAY)THEN RETURN SETERROR(1,0,0)
IF UBOUND($AVARRAY,0)<>1 THEN RETURN SETERROR(2,0,0)
LOCAL $IN=UBOUND($AVARRAY)
LOCAL $IR=$ISET
LOCAL $AIDX[$IR]
FOR $I=0 TO $IR-1
$AIDX[$I]=$I
NEXT
LOCAL $ITOTAL=__ARRAY_COMBINATIONS($IN,$IR)
LOCAL $ILEFT=$ITOTAL
LOCAL $ARESULT[$ITOTAL+1]
$ARESULT[0]=$ITOTAL
LOCAL $ICOUNT=1
WHILE $ILEFT>0
__ARRAY_GETNEXT($IN,$IR,$ILEFT,$ITOTAL,$AIDX)
FOR $I=0 TO $ISET-1
$ARESULT[$ICOUNT]&=$AVARRAY[$AIDX[$I]]&$SDELIM
NEXT
IF $SDELIM<>"" THEN $ARESULT[$ICOUNT]=STRINGTRIMRIGHT($ARESULT[$ICOUNT],1)
$ICOUNT+=1
WEND
RETURN $ARESULT
ENDFUNC
FUNC _ARRAYCONCATENATE(BYREF $AVARRAYTARGET,CONST BYREF $AVARRAYSOURCE,$ISTART=0)
IF NOT ISARRAY($AVARRAYTARGET)THEN RETURN SETERROR(1,0,0)
IF NOT ISARRAY($AVARRAYSOURCE)THEN RETURN SETERROR(2,0,0)
IF UBOUND($AVARRAYTARGET,0)<>1 THEN
IF UBOUND($AVARRAYSOURCE,0)<>1 THEN RETURN SETERROR(5,0,0)
RETURN SETERROR(3,0,0)
ENDIF
IF UBOUND($AVARRAYSOURCE,0)<>1 THEN RETURN SETERROR(4,0,0)
LOCAL $IUBOUNDTARGET=UBOUND($AVARRAYTARGET)-$ISTART,$IUBOUNDSOURCE=UBOUND($AVARRAYSOURCE)
REDIM $AVARRAYTARGET[$IUBOUNDTARGET+$IUBOUNDSOURCE]
FOR $I=$ISTART TO $IUBOUNDSOURCE-1
$AVARRAYTARGET[$IUBOUNDTARGET+$I]=$AVARRAYSOURCE[$I]
NEXT
RETURN $IUBOUNDTARGET+$IUBOUNDSOURCE
ENDFUNC
FUNC _ARRAYDELETE(BYREF $AVARRAY,$IELEMENT)
IF NOT ISARRAY($AVARRAY)THEN RETURN SETERROR(1,0,0)
LOCAL $IUBOUND=UBOUND($AVARRAY,1)-1
IF $IELEMENT<0 THEN $IELEMENT=0
IF $IELEMENT>$IUBOUND THEN $IELEMENT=$IUBOUND
SWITCH UBOUND($AVARRAY,0)
CASE 1
FOR $I=$IELEMENT TO $IUBOUND-1
$AVARRAY[$I]=$AVARRAY[$I+1]
NEXT
REDIM $AVARRAY[$IUBOUND]
CASE 2
LOCAL $ISUBMAX=UBOUND($AVARRAY,2)-1
FOR $I=$IELEMENT TO $IUBOUND-1
FOR $J=0 TO $ISUBMAX
$AVARRAY[$I][$J]=$AVARRAY[$I+1][$J]
NEXT
NEXT
REDIM $AVARRAY[$IUBOUND][$ISUBMAX+1]
CASE ELSE
RETURN SETERROR(3,0,0)
ENDSWITCH
RETURN $IUBOUND
ENDFUNC
FUNC _ARRAYDISPLAY(CONST BYREF $AVARRAY,$STITLE=DEFAULT ,$SARRAY_RANGE=DEFAULT ,$IFLAGS=DEFAULT ,$VUSER_SEPARATOR=DEFAULT ,$SHEADER=DEFAULT ,$IMAX_COLWIDTH=DEFAULT ,$IALT_COLOR=DEFAULT ,$HUSER_FUNC=DEFAULT )
LOCAL CONST $_ARRAYCONSTANT_MB_SYSTEMMODAL=4096
LOCAL CONST $_ARRAYCONSTANT_MB_ICONERROR=16
LOCAL CONST $_ARRAYCONSTANT_MB_YESNO=4
LOCAL CONST $_ARRAYCONSTANT_IDYES=6
IF $STITLE=DEFAULT THEN $STITLE="ArrayDisplay"
IF $SARRAY_RANGE=DEFAULT THEN $SARRAY_RANGE=""
IF $IFLAGS=DEFAULT THEN $IFLAGS=0
IF $VUSER_SEPARATOR=DEFAULT THEN $VUSER_SEPARATOR=""
IF $SHEADER=DEFAULT THEN $SHEADER=""
IF $IMAX_COLWIDTH=DEFAULT THEN $IMAX_COLWIDTH=350
IF $IALT_COLOR=DEFAULT THEN $IALT_COLOR=0
IF $HUSER_FUNC=DEFAULT THEN $HUSER_FUNC=0
LOCAL $ITRANSPOSE=BITAND($IFLAGS,1)
LOCAL $ICOLALIGN=BITAND($IFLAGS,6)
LOCAL $IVERBOSE=BITAND($IFLAGS,8)
LOCAL $SMSG="",$IRET
IF ISARRAY($AVARRAY)THEN
LOCAL $IDIMENSION=UBOUND($AVARRAY,0),$IROWCOUNT=UBOUND($AVARRAY,1),$ICOLCOUNT=UBOUND($AVARRAY,2)
IF $IDIMENSION>2 THEN
$SMSG="Larger than 2D array passed to function"
$IRET=2
ENDIF
ELSE
$SMSG="No array variable passed to function"
$IRET=1
ENDIF
IF $SMSG THEN
IF $IVERBOSE AND MSGBOX($_ARRAYCONSTANT_MB_SYSTEMMODAL+$_ARRAYCONSTANT_MB_ICONERROR+$_ARRAYCONSTANT_MB_YESNO,"ArrayDisplay Error: "&$STITLE,$SMSG&@CRLF&@CRLF&"Exit the script?")=$_ARRAYCONSTANT_IDYES THEN
EXIT
ELSE
RETURN SETERROR($IRET,0,"")
ENDIF
ENDIF
LOCAL $ICW_COLWIDTH=NUMBER($VUSER_SEPARATOR)
LOCAL $SAD_SEPARATOR=CHRW(64177)
LOCAL $SCURR_SEPARATOR=OPT("GUIDataSeparatorChar",$SAD_SEPARATOR)
IF $VUSER_SEPARATOR="" THEN $VUSER_SEPARATOR=$SCURR_SEPARATOR
LOCAL $VTMP,$IROWLIMIT=65525,$ICOLLIMIT=250
LOCAL $IDATAROW=$IROWCOUNT
LOCAL $IDATACOL=$ICOLCOUNT
LOCAL $IITEM_START=0,$IITEM_END=$IROWCOUNT-1,$ISUBITEM_START=0,$ISUBITEM_END=$ICOLCOUNT-1,$AVDIMSPLIT,$AVRANGESPLIT
IF $IDIMENSION=1 THEN $ISUBITEM_END=0
IF $SARRAY_RANGE THEN
IF (NOT STRINGINSTR($SARRAY_RANGE,"|"))THEN
$SARRAY_RANGE&="|"
ENDIF
$AVDIMSPLIT=STRINGSPLIT($SARRAY_RANGE,"|")
IF NOT @ERROR THEN
$AVRANGESPLIT=STRINGSPLIT($AVDIMSPLIT[1],":")
IF @ERROR THEN
$IITEM_START=0
IF NUMBER($AVRANGESPLIT[1])THEN
$IITEM_END=NUMBER($AVRANGESPLIT[1])
ENDIF
ELSE
$IITEM_START=NUMBER($AVRANGESPLIT[1])
IF NUMBER($AVRANGESPLIT[2])THEN
$IITEM_END=NUMBER($AVRANGESPLIT[2])
ENDIF
ENDIF
$AVRANGESPLIT=STRINGSPLIT($AVDIMSPLIT[2],":")
IF @ERROR THEN
$ISUBITEM_START=0
IF NUMBER($AVRANGESPLIT[1])THEN
$ISUBITEM_END=NUMBER($AVRANGESPLIT[1])
ENDIF
ELSE
$ISUBITEM_START=NUMBER($AVRANGESPLIT[1])
IF NUMBER($AVRANGESPLIT[2])THEN
$ISUBITEM_END=NUMBER($AVRANGESPLIT[2])
ENDIF
ENDIF
IF $IITEM_START<0 THEN $IITEM_START=0
IF $ISUBITEM_START<0 THEN $ISUBITEM_START=0
IF $IITEM_END>$IROWCOUNT-1 THEN $IITEM_END=$IROWCOUNT-1
IF $ISUBITEM_END>$ICOLCOUNT-1 THEN $ISUBITEM_END=$ICOLCOUNT-1
ENDIF
ENDIF
LOCAL $SDISPLAYDATA="["&$IDATAROW
LOCAL $FTRUNCATED=FALSE
IF $ITRANSPOSE THEN
IF $IITEM_END-$IITEM_START>$ICOLLIMIT THEN
$FTRUNCATED=TRUE
$IITEM_END=$IITEM_START+$ICOLLIMIT-1
ENDIF
ELSE
IF $IITEM_END-$IITEM_START>$IROWLIMIT THEN
$FTRUNCATED=TRUE
$IITEM_END=$IITEM_START+$IROWLIMIT-1
ENDIF
ENDIF
IF $FTRUNCATED THEN
$SDISPLAYDATA&="*]"
ELSE
$SDISPLAYDATA&="]"
ENDIF
IF $IDIMENSION=2 THEN
$SDISPLAYDATA&=" ["&$IDATACOL
IF $ITRANSPOSE THEN
IF $ISUBITEM_END-$ISUBITEM_START>$IROWLIMIT THEN
$FTRUNCATED=TRUE
$ISUBITEM_END=$ISUBITEM_START+$IROWLIMIT-1
ENDIF
ELSE
IF $ISUBITEM_END-$ISUBITEM_START>$ICOLLIMIT THEN
$FTRUNCATED=TRUE
$ISUBITEM_END=$ISUBITEM_START+$ICOLLIMIT-1
ENDIF
ENDIF
IF $FTRUNCATED THEN
$SDISPLAYDATA&="*]"
ELSE
$SDISPLAYDATA&="]"
ENDIF
ENDIF
LOCAL $STIPDATA=""
IF $FTRUNCATED THEN $STIPDATA&="Truncated"
IF $SARRAY_RANGE THEN
IF $STIPDATA THEN $STIPDATA&=" - "
$STIPDATA&="Range set"
ENDIF
IF $ITRANSPOSE THEN
IF $STIPDATA THEN $STIPDATA&=" - "
$STIPDATA&="Transposed"
ENDIF
LOCAL $ASHEADER=STRINGSPLIT($SHEADER,$SCURR_SEPARATOR,2)
$SHEADER="Row"
LOCAL $IINDEX=$ISUBITEM_START
IF $ITRANSPOSE THEN
FOR $J=$IITEM_START TO $IITEM_END
$SHEADER&=$SAD_SEPARATOR&"Col "&$J
NEXT
ELSE
IF $ASHEADER[0]THEN
FOR $IINDEX=$ISUBITEM_START TO $ISUBITEM_END
IF $IINDEX>=UBOUND($ASHEADER)THEN EXITLOOP
$SHEADER&=$SAD_SEPARATOR&$ASHEADER[$IINDEX]
NEXT
ENDIF
FOR $J=$IINDEX TO $ISUBITEM_END
$SHEADER&=$SAD_SEPARATOR&"Col "&$J
NEXT
ENDIF
IF $IVERBOSE AND ($IITEM_END-$IITEM_START)*($ISUBITEM_END-$ISUBITEM_START)>10000 THEN
SPLASHTEXTON("ArrayDisplay","Preparing display"&@CRLF&@CRLF&"Please be patient",300,100)
ENDIF
IF $ITRANSPOSE THEN
$VTMP=$IITEM_START
$IITEM_START=$ISUBITEM_START
$ISUBITEM_START=$VTMP
$VTMP=$IITEM_END
$IITEM_END=$ISUBITEM_END
$ISUBITEM_END=$VTMP
ENDIF
LOCAL $AVARRAYTEXT[$IITEM_END-$IITEM_START+1]
FOR $I=$IITEM_START TO $IITEM_END
$AVARRAYTEXT[$I-$IITEM_START]="["&$I&"]"
FOR $J=$ISUBITEM_START TO $ISUBITEM_END
IF $IDIMENSION=1 THEN
IF $ITRANSPOSE THEN
$VTMP=$AVARRAY[$J]
ELSE
$VTMP=$AVARRAY[$I]
ENDIF
ELSE
IF $ITRANSPOSE THEN
$VTMP=$AVARRAY[$J][$I]
ELSE
$VTMP=$AVARRAY[$I][$J]
ENDIF
ENDIF
$AVARRAYTEXT[$I-$IITEM_START]&=$SAD_SEPARATOR&$VTMP
NEXT
NEXT
LOCAL CONST $_ARRAYCONSTANT_GUI_DOCKBOTTOM=64
LOCAL CONST $_ARRAYCONSTANT_GUI_DOCKBORDERS=102
LOCAL CONST $_ARRAYCONSTANT_GUI_DOCKHEIGHT=512
LOCAL CONST $_ARRAYCONSTANT_GUI_DOCKLEFT=2
LOCAL CONST $_ARRAYCONSTANT_GUI_DOCKRIGHT=4
LOCAL CONST $_ARRAYCONSTANT_GUI_DOCKHCENTER=8
LOCAL CONST $_ARRAYCONSTANT_GUI_EVENT_CLOSE=-3
LOCAL CONST $_ARRAYCONSTANT_GUI_DISABLE=128
LOCAL CONST $_ARRAYCONSTANT_GUI_FOCUS=256
LOCAL CONST $_ARRAYCONSTANT_GUI_BKCOLOR_LV_ALTERNATE=-33554432
LOCAL CONST $_ARRAYCONSTANT_SS_CENTER=1
LOCAL CONST $_ARRAYCONSTANT_SS_CENTERIMAGE=512
LOCAL CONST $_ARRAYCONSTANT_LVM_GETITEMCOUNT=(4096+4)
LOCAL CONST $_ARRAYCONSTANT_LVM_GETITEMRECT=(4096+14)
LOCAL CONST $_ARRAYCONSTANT_LVM_GETCOLUMNWIDTH=(4096+29)
LOCAL CONST $_ARRAYCONSTANT_LVM_SETCOLUMNWIDTH=(4096+30)
LOCAL CONST $_ARRAYCONSTANT_LVM_GETITEMSTATE=(4096+44)
LOCAL CONST $_ARRAYCONSTANT_LVM_GETSELECTEDCOUNT=(4096+50)
LOCAL CONST $_ARRAYCONSTANT_LVM_SETEXTENDEDLISTVIEWSTYLE=(4096+54)
LOCAL CONST $_ARRAYCONSTANT_LVS_EX_GRIDLINES=1
LOCAL CONST $_ARRAYCONSTANT_LVIS_SELECTED=2
LOCAL CONST $_ARRAYCONSTANT_LVS_SHOWSELALWAYS=8
LOCAL CONST $_ARRAYCONSTANT_LVS_EX_FULLROWSELECT=32
LOCAL CONST $_ARRAYCONSTANT_WS_EX_CLIENTEDGE=512
LOCAL CONST $_ARRAYCONSTANT_WS_MAXIMIZEBOX=65536
LOCAL CONST $_ARRAYCONSTANT_WS_MINIMIZEBOX=131072
LOCAL CONST $_ARRAYCONSTANT_WS_SIZEBOX=262144
LOCAL CONST $_ARRAYCONSTANT_WM_SETREDRAW=11
LOCAL CONST $_ARRAYCONSTANT_LVSCW_AUTOSIZE=-1
LOCAL $IORGWIDTH=210,$IHEIGHT=200,$IMINSIZE=250
LOCAL $HGUI=GUICREATE($STITLE,$IORGWIDTH,$IHEIGHT,DEFAULT ,DEFAULT ,BITOR($_ARRAYCONSTANT_WS_SIZEBOX,$_ARRAYCONSTANT_WS_MINIMIZEBOX,$_ARRAYCONSTANT_WS_MAXIMIZEBOX))
LOCAL $AIGUISIZE=WINGETCLIENTSIZE($HGUI)
LOCAL $IBUTTONWIDTH_2=$AIGUISIZE[0]/2
LOCAL $IBUTTONWIDTH_3=$AIGUISIZE[0]/3
LOCAL $CLISTVIEW=GUICTRLCREATELISTVIEW($SHEADER,0,0,$AIGUISIZE[0],$AIGUISIZE[1]-46,$_ARRAYCONSTANT_LVS_SHOWSELALWAYS)
GUICTRLSETBKCOLOR($CLISTVIEW,$_ARRAYCONSTANT_GUI_BKCOLOR_LV_ALTERNATE)
GUICTRLSENDMSG($CLISTVIEW,$_ARRAYCONSTANT_LVM_SETEXTENDEDLISTVIEWSTYLE,$_ARRAYCONSTANT_LVS_EX_GRIDLINES,$_ARRAYCONSTANT_LVS_EX_GRIDLINES)
GUICTRLSENDMSG($CLISTVIEW,$_ARRAYCONSTANT_LVM_SETEXTENDEDLISTVIEWSTYLE,$_ARRAYCONSTANT_LVS_EX_FULLROWSELECT,$_ARRAYCONSTANT_LVS_EX_FULLROWSELECT)
GUICTRLSENDMSG($CLISTVIEW,$_ARRAYCONSTANT_LVM_SETEXTENDEDLISTVIEWSTYLE,$_ARRAYCONSTANT_WS_EX_CLIENTEDGE,$_ARRAYCONSTANT_WS_EX_CLIENTEDGE)
LOCAL $CCOPY_ID=GUICTRLCREATEBUTTON("Copy Data && Hdr/Row",0,$AIGUISIZE[1]-43,$IBUTTONWIDTH_2,20)
LOCAL $CCOPY_DATA=GUICTRLCREATEBUTTON("Copy Data Only",$IBUTTONWIDTH_2,$AIGUISIZE[1]-43,$IBUTTONWIDTH_2,20)
LOCAL $CDATA_LABEL=GUICTRLCREATELABEL($SDISPLAYDATA,5,$AIGUISIZE[1]-22,$IBUTTONWIDTH_3-5,18,BITOR($_ARRAYCONSTANT_SS_CENTER,$_ARRAYCONSTANT_SS_CENTERIMAGE))
LOCAL $CUSER_FUNC=GUICTRLCREATEBUTTON("Run User Func",$IBUTTONWIDTH_3,$AIGUISIZE[1]-23,$IBUTTONWIDTH_3,20)
IF NOT ISFUNC($HUSER_FUNC)THEN GUICTRLSETSTATE($CUSER_FUNC,$_ARRAYCONSTANT_GUI_DISABLE)
LOCAL $CEXIT_SCRIPT=GUICTRLCREATEBUTTON("Exit Script",$IBUTTONWIDTH_3*2,$AIGUISIZE[1]-23,$IBUTTONWIDTH_3,20)
SELECT
CASE $FTRUNCATED OR $ITRANSPOSE OR $SARRAY_RANGE
GUICTRLSETCOLOR($CDATA_LABEL,16711680)
GUICTRLSETTIP($CDATA_LABEL,$STIPDATA)
ENDSELECT
GUICTRLSETRESIZING($CLISTVIEW,$_ARRAYCONSTANT_GUI_DOCKBORDERS)
GUICTRLSETRESIZING($CCOPY_ID,$_ARRAYCONSTANT_GUI_DOCKLEFT+$_ARRAYCONSTANT_GUI_DOCKBOTTOM+$_ARRAYCONSTANT_GUI_DOCKHEIGHT)
GUICTRLSETRESIZING($CCOPY_DATA,$_ARRAYCONSTANT_GUI_DOCKRIGHT+$_ARRAYCONSTANT_GUI_DOCKBOTTOM+$_ARRAYCONSTANT_GUI_DOCKHEIGHT)
GUICTRLSETRESIZING($CDATA_LABEL,$_ARRAYCONSTANT_GUI_DOCKLEFT+$_ARRAYCONSTANT_GUI_DOCKBOTTOM+$_ARRAYCONSTANT_GUI_DOCKHEIGHT)
GUICTRLSETRESIZING($CUSER_FUNC,$_ARRAYCONSTANT_GUI_DOCKHCENTER+$_ARRAYCONSTANT_GUI_DOCKBOTTOM+$_ARRAYCONSTANT_GUI_DOCKHEIGHT)
GUICTRLSETRESIZING($CEXIT_SCRIPT,$_ARRAYCONSTANT_GUI_DOCKRIGHT+$_ARRAYCONSTANT_GUI_DOCKBOTTOM+$_ARRAYCONSTANT_GUI_DOCKHEIGHT)
GUICTRLSENDMSG($CLISTVIEW,$_ARRAYCONSTANT_WM_SETREDRAW,0,0)
LOCAL $CITEM
FOR $I=0 TO UBOUND($AVARRAYTEXT)-1
$CITEM=GUICTRLCREATELISTVIEWITEM($AVARRAYTEXT[$I],$CLISTVIEW)
IF $IALT_COLOR THEN
GUICTRLSETBKCOLOR($CITEM,$IALT_COLOR)
ENDIF
NEXT
IF $ICOLALIGN THEN
LOCAL CONST $_ARRAYCONSTANT_LVCF_FMT=1
LOCAL CONST $_ARRAYCONSTANT_LVM_SETCOLUMNW=(4096+96)
LOCAL $TCOLUMN=DLLSTRUCTCREATE("uint Mask;int Fmt;int CX;ptr Text;int TextMax;int SubItem;int Image;int Order;int cxMin;int cxDefault;int cxIdeal")
DLLSTRUCTSETDATA($TCOLUMN,"Mask",$_ARRAYCONSTANT_LVCF_FMT)
DLLSTRUCTSETDATA($TCOLUMN,"Fmt",$ICOLALIGN/2)
LOCAL $PCOLUMN=DLLSTRUCTGETPTR($TCOLUMN)
FOR $I=1 TO $ISUBITEM_END-$ISUBITEM_START+1
GUICTRLSENDMSG($CLISTVIEW,$_ARRAYCONSTANT_LVM_SETCOLUMNW,$I,$PCOLUMN)
NEXT
ENDIF
GUICTRLSENDMSG($CLISTVIEW,$_ARRAYCONSTANT_WM_SETREDRAW,1,0)
LOCAL $IBORDER=45
IF UBOUND($AVARRAYTEXT)>20 THEN
$IBORDER+=20
ENDIF
LOCAL $IWIDTH=$IBORDER,$ICOLWIDTH=0,$AICOLWIDTH[$ISUBITEM_END-$ISUBITEM_START+2],$IMIN_COLWIDTH=55
FOR $I=0 TO $ISUBITEM_END-$ISUBITEM_START+1
GUICTRLSENDMSG($CLISTVIEW,$_ARRAYCONSTANT_LVM_SETCOLUMNWIDTH,$I,$_ARRAYCONSTANT_LVSCW_AUTOSIZE)
$ICOLWIDTH=GUICTRLSENDMSG($CLISTVIEW,$_ARRAYCONSTANT_LVM_GETCOLUMNWIDTH,$I,0)
IF $ICOLWIDTH<$IMIN_COLWIDTH THEN
GUICTRLSENDMSG($CLISTVIEW,$_ARRAYCONSTANT_LVM_SETCOLUMNWIDTH,$I,$IMIN_COLWIDTH)
$ICOLWIDTH=$IMIN_COLWIDTH
ENDIF
$IWIDTH+=$ICOLWIDTH
$AICOLWIDTH[$I]=$ICOLWIDTH
NEXT
IF $IWIDTH>@DESKTOPWIDTH-100 THEN
$IWIDTH=$IBORDER
FOR $I=0 TO $ISUBITEM_END-$ISUBITEM_START+1
IF $AICOLWIDTH[$I]>$IMAX_COLWIDTH THEN
GUICTRLSENDMSG($CLISTVIEW,$_ARRAYCONSTANT_LVM_SETCOLUMNWIDTH,$I,$IMAX_COLWIDTH)
$IWIDTH+=$IMAX_COLWIDTH
ELSE
$IWIDTH+=$AICOLWIDTH[$I]
ENDIF
NEXT
ENDIF
IF $IWIDTH>@DESKTOPWIDTH-100 THEN
$IWIDTH=@DESKTOPWIDTH-100
ELSEIF $IWIDTH<$IMINSIZE THEN
$IWIDTH=$IMINSIZE
ENDIF
LOCAL $TRECT=DLLSTRUCTCREATE("struct; long Left;long Top;long Right;long Bottom; endstruct")
DLLCALL("user32.dll","struct*","SendMessageW","hwnd",GUICTRLGETHANDLE($CLISTVIEW),"uint",$_ARRAYCONSTANT_LVM_GETITEMRECT,"wparam",0,"struct*",$TRECT)
LOCAL $AIWIN_POS=WINGETPOS($HGUI)
LOCAL $AILV_POS=CONTROLGETPOS($HGUI,"",$CLISTVIEW)
$IHEIGHT=((UBOUND($AVARRAYTEXT)+3)*(DLLSTRUCTGETDATA($TRECT,"Bottom")-DLLSTRUCTGETDATA($TRECT,"Top")))+$AIWIN_POS[3]-$AILV_POS[3]
IF $IHEIGHT>@DESKTOPHEIGHT-100 THEN
$IHEIGHT=@DESKTOPHEIGHT-100
ELSEIF $IHEIGHT<$IMINSIZE THEN
$IHEIGHT=$IMINSIZE
ENDIF
SPLASHOFF()
GUISETSTATE(@SW_HIDE,$HGUI)
WINMOVE($HGUI,"",(@DESKTOPWIDTH-$IWIDTH)/2,(@DESKTOPHEIGHT-$IHEIGHT)/2,$IWIDTH,$IHEIGHT)
GUISETSTATE(@SW_SHOW,$HGUI)
LOCAL $IONEVENTMODE=OPT("GUIOnEventMode",0),$IMSG
WHILE 1
$IMSG=GUIGETMSG()
SWITCH $IMSG
CASE $_ARRAYCONSTANT_GUI_EVENT_CLOSE
EXITLOOP
CASE $CCOPY_ID,$CCOPY_DATA
LOCAL $ISEL_COUNT=GUICTRLSENDMSG($CLISTVIEW,$_ARRAYCONSTANT_LVM_GETSELECTEDCOUNT,0,0)
IF $IVERBOSE AND (NOT $ISEL_COUNT)AND ($IITEM_END-$IITEM_START)*($ISUBITEM_END-$ISUBITEM_START)>10000 THEN
SPLASHTEXTON("ArrayDisplay","Copying data"&@CRLF&@CRLF&"Please be patient",300,100)
ENDIF
LOCAL $SCLIP="",$SITEM,$ASPLIT
FOR $I=0 TO $IITEM_END-$IITEM_START
IF $ISEL_COUNT AND NOT (GUICTRLSENDMSG($CLISTVIEW,$_ARRAYCONSTANT_LVM_GETITEMSTATE,$I,$_ARRAYCONSTANT_LVIS_SELECTED))THEN
CONTINUELOOP
ENDIF
$SITEM=$AVARRAYTEXT[$I]
IF $IMSG=$CCOPY_DATA THEN
$SITEM=STRINGREGEXPREPLACE($SITEM,"^\[\d+\].(.*)$","$1")
ENDIF
IF $ICW_COLWIDTH THEN
$ASPLIT=STRINGSPLIT($SITEM,$SAD_SEPARATOR)
$SITEM=""
FOR $J=1 TO $ASPLIT[0]
$SITEM&=STRINGFORMAT("%-"&$ICW_COLWIDTH+1&"s",STRINGLEFT($ASPLIT[$J],$ICW_COLWIDTH))
NEXT
ELSE
$SITEM=STRINGREPLACE($SITEM,$SAD_SEPARATOR,$VUSER_SEPARATOR)
ENDIF
$SCLIP&=$SITEM&@CRLF
NEXT
IF $IMSG=$CCOPY_ID THEN
IF $ICW_COLWIDTH THEN
$ASPLIT=STRINGSPLIT($SHEADER,$SAD_SEPARATOR)
$SITEM=""
FOR $J=1 TO $ASPLIT[0]
$SITEM&=STRINGFORMAT("%-"&$ICW_COLWIDTH+1&"s",STRINGLEFT($ASPLIT[$J],$ICW_COLWIDTH))
NEXT
ELSE
$SITEM=STRINGREPLACE($SHEADER,$SAD_SEPARATOR,$VUSER_SEPARATOR)
ENDIF
$SCLIP=$SITEM&@CRLF&$SCLIP
ENDIF
CLIPPUT($SCLIP)
SPLASHOFF()
GUICTRLSETSTATE($CLISTVIEW,$_ARRAYCONSTANT_GUI_FOCUS)
CASE $CUSER_FUNC
LOCAL $AISELITEMS[$IROWLIMIT]=[0]
FOR $I=0 TO GUICTRLSENDMSG($CLISTVIEW,$_ARRAYCONSTANT_LVM_GETITEMCOUNT,0,0)
IF GUICTRLSENDMSG($CLISTVIEW,$_ARRAYCONSTANT_LVM_GETITEMSTATE,$I,$_ARRAYCONSTANT_LVIS_SELECTED)THEN
$AISELITEMS[0]+=1
$AISELITEMS[$AISELITEMS[0]]=$I+$IITEM_START
ENDIF
NEXT
REDIM $AISELITEMS[$AISELITEMS[0]+1]
$HUSER_FUNC($AVARRAY,$AISELITEMS)
GUICTRLSETSTATE($CLISTVIEW,$_ARRAYCONSTANT_GUI_FOCUS)
CASE $CEXIT_SCRIPT
EXIT
ENDSWITCH
WEND
GUIDELETE($HGUI)
OPT("GUIOnEventMode",$IONEVENTMODE)
OPT("GUIDataSeparatorChar",$SCURR_SEPARATOR)
RETURN 1
ENDFUNC
FUNC _ARRAYFINDALL(CONST BYREF $AVARRAY,$VVALUE,$ISTART=0,$IEND=0,$ICASE=0,$ICOMPARE=0,$ISUBITEM=0)
$ISTART=_ARRAYSEARCH($AVARRAY,$VVALUE,$ISTART,$IEND,$ICASE,$ICOMPARE,1,$ISUBITEM)
IF @ERROR THEN RETURN SETERROR(@ERROR,0,-1)
LOCAL $IINDEX=0,$AVRESULT[UBOUND($AVARRAY)]
DO
$AVRESULT[$IINDEX]=$ISTART
$IINDEX+=1
$ISTART=_ARRAYSEARCH($AVARRAY,$VVALUE,$ISTART+1,$IEND,$ICASE,$ICOMPARE,1,$ISUBITEM)
UNTIL @ERROR
REDIM $AVRESULT[$IINDEX]
RETURN $AVRESULT
ENDFUNC
FUNC _ARRAYINSERT(BYREF $AVARRAY,$IELEMENT,$VVALUE="")
IF NOT ISARRAY($AVARRAY)THEN RETURN SETERROR(1,0,0)
IF UBOUND($AVARRAY,0)<>1 THEN RETURN SETERROR(2,0,0)
IF $IELEMENT>UBOUND($AVARRAY)THEN RETURN SETERROR(3,0,0)
LOCAL $IUBOUND=UBOUND($AVARRAY)+1
REDIM $AVARRAY[$IUBOUND]
FOR $I=$IUBOUND-1 TO $IELEMENT+1 STEP -1
$AVARRAY[$I]=$AVARRAY[$I-1]
NEXT
$AVARRAY[$IELEMENT]=$VVALUE
RETURN $IUBOUND
ENDFUNC
FUNC _ARRAYMAX(CONST BYREF $AVARRAY,$ICOMPNUMERIC=0,$ISTART=0,$IEND=0)
LOCAL $IRESULT=_ARRAYMAXINDEX($AVARRAY,$ICOMPNUMERIC,$ISTART,$IEND)
IF @ERROR THEN RETURN SETERROR(@ERROR,0,"")
RETURN $AVARRAY[$IRESULT]
ENDFUNC
FUNC _ARRAYMAXINDEX(CONST BYREF $AVARRAY,$ICOMPNUMERIC=0,$ISTART=0,$IEND=0)
IF NOT ISARRAY($AVARRAY)THEN RETURN SETERROR(1,0,-1)
IF UBOUND($AVARRAY,0)<>1 THEN RETURN SETERROR(3,0,-1)
IF NOT UBOUND($AVARRAY)THEN RETURN SETERROR(4,0,-1)
LOCAL $IUBOUND=UBOUND($AVARRAY)-1
IF $IEND<1 OR $IEND>$IUBOUND THEN $IEND=$IUBOUND
IF $ISTART<0 THEN $ISTART=0
IF $ISTART>$IEND THEN RETURN SETERROR(2,0,-1)
LOCAL $IMAXINDEX=$ISTART
IF $ICOMPNUMERIC THEN
FOR $I=$ISTART TO $IEND
IF NUMBER($AVARRAY[$IMAXINDEX])<NUMBER($AVARRAY[$I])THEN $IMAXINDEX=$I
NEXT
ELSE
FOR $I=$ISTART TO $IEND
IF $AVARRAY[$IMAXINDEX]<$AVARRAY[$I]THEN $IMAXINDEX=$I
NEXT
ENDIF
RETURN $IMAXINDEX
ENDFUNC
FUNC _ARRAYMIN(CONST BYREF $AVARRAY,$ICOMPNUMERIC=0,$ISTART=0,$IEND=0)
LOCAL $IRESULT=_ARRAYMININDEX($AVARRAY,$ICOMPNUMERIC,$ISTART,$IEND)
IF @ERROR THEN RETURN SETERROR(@ERROR,0,"")
RETURN $AVARRAY[$IRESULT]
ENDFUNC
FUNC _ARRAYMININDEX(CONST BYREF $AVARRAY,$ICOMPNUMERIC=0,$ISTART=0,$IEND=0)
IF NOT ISARRAY($AVARRAY)THEN RETURN SETERROR(1,0,-1)
IF UBOUND($AVARRAY,0)<>1 THEN RETURN SETERROR(3,0,-1)
IF NOT UBOUND($AVARRAY)THEN RETURN SETERROR(4,0,-1)
LOCAL $IUBOUND=UBOUND($AVARRAY)-1
IF $IEND<1 OR $IEND>$IUBOUND THEN $IEND=$IUBOUND
IF $ISTART<0 THEN $ISTART=0
IF $ISTART>$IEND THEN RETURN SETERROR(2,0,-1)
LOCAL $IMININDEX=$ISTART
IF $ICOMPNUMERIC THEN
FOR $I=$ISTART TO $IEND
IF NUMBER($AVARRAY[$IMININDEX])>NUMBER($AVARRAY[$I])THEN $IMININDEX=$I
NEXT
ELSE
FOR $I=$ISTART TO $IEND
IF $AVARRAY[$IMININDEX]>$AVARRAY[$I]THEN $IMININDEX=$I
NEXT
ENDIF
RETURN $IMININDEX
ENDFUNC
FUNC _ARRAYPERMUTE(BYREF $AVARRAY,$SDELIM="")
IF NOT ISARRAY($AVARRAY)THEN RETURN SETERROR(1,0,0)
IF UBOUND($AVARRAY,0)<>1 THEN RETURN SETERROR(2,0,0)
LOCAL $ISIZE=UBOUND($AVARRAY),$IFACTORIAL=1,$AIDX[$ISIZE],$ARESULT[1],$ICOUNT=1
IF UBOUND($AVARRAY)THEN
FOR $I=0 TO $ISIZE-1
$AIDX[$I]=$I
NEXT
FOR $I=$ISIZE TO 1 STEP -1
$IFACTORIAL*=$I
NEXT
REDIM $ARESULT[$IFACTORIAL+1]
$ARESULT[0]=$IFACTORIAL
__ARRAY_EXETERINTERNAL($AVARRAY,0,$ISIZE,$SDELIM,$AIDX,$ARESULT,$ICOUNT)
ELSE
$ARESULT[0]=0
ENDIF
RETURN $ARESULT
ENDFUNC
FUNC _ARRAYPOP(BYREF $AVARRAY)
IF (NOT ISARRAY($AVARRAY))THEN RETURN SETERROR(1,0,"")
IF UBOUND($AVARRAY,0)<>1 THEN RETURN SETERROR(2,0,"")
LOCAL $IUBOUND=UBOUND($AVARRAY)-1
IF $IUBOUND=-1 THEN RETURN SETERROR(3,0,"")
LOCAL $SLASTVAL=$AVARRAY[$IUBOUND]
IF $IUBOUND>-1 THEN
REDIM $AVARRAY[$IUBOUND]
ENDIF
RETURN $SLASTVAL
ENDFUNC
FUNC _ARRAYPUSH(BYREF $AVARRAY,$VVALUE,$IDIRECTION=0)
IF (NOT ISARRAY($AVARRAY))THEN RETURN SETERROR(1,0,0)
IF UBOUND($AVARRAY,0)<>1 THEN RETURN SETERROR(3,0,0)
LOCAL $IUBOUND=UBOUND($AVARRAY)-1
IF ISARRAY($VVALUE)THEN
LOCAL $IUBOUNDS=UBOUND($VVALUE)
IF ($IUBOUNDS-1)>$IUBOUND THEN RETURN SETERROR(2,0,0)
IF $IDIRECTION THEN
FOR $I=$IUBOUND TO $IUBOUNDS STEP -1
$AVARRAY[$I]=$AVARRAY[$I-$IUBOUNDS]
NEXT
FOR $I=0 TO $IUBOUNDS-1
$AVARRAY[$I]=$VVALUE[$I]
NEXT
ELSE
FOR $I=0 TO $IUBOUND-$IUBOUNDS
$AVARRAY[$I]=$AVARRAY[$I+$IUBOUNDS]
NEXT
FOR $I=0 TO $IUBOUNDS-1
$AVARRAY[$I+$IUBOUND-$IUBOUNDS+1]=$VVALUE[$I]
NEXT
ENDIF
ELSE
IF $IUBOUND>-1 THEN
IF $IDIRECTION THEN
FOR $I=$IUBOUND TO 1 STEP -1
$AVARRAY[$I]=$AVARRAY[$I-1]
NEXT
$AVARRAY[0]=$VVALUE
ELSE
FOR $I=0 TO $IUBOUND-1
$AVARRAY[$I]=$AVARRAY[$I+1]
NEXT
$AVARRAY[$IUBOUND]=$VVALUE
ENDIF
ENDIF
ENDIF
RETURN 1
ENDFUNC
FUNC _ARRAYREVERSE(BYREF $AVARRAY,$ISTART=0,$IEND=0)
IF NOT ISARRAY($AVARRAY)THEN RETURN SETERROR(1,0,0)
IF UBOUND($AVARRAY,0)<>1 THEN RETURN SETERROR(3,0,0)
IF NOT UBOUND($AVARRAY)THEN RETURN SETERROR(4,0,0)
LOCAL $VTMP,$IUBOUND=UBOUND($AVARRAY)-1
IF $IEND<1 OR $IEND>$IUBOUND THEN $IEND=$IUBOUND
IF $ISTART<0 THEN $ISTART=0
IF $ISTART>$IEND THEN RETURN SETERROR(2,0,0)
FOR $I=$ISTART TO INT(($ISTART+$IEND-1)/2)
$VTMP=$AVARRAY[$I]
$AVARRAY[$I]=$AVARRAY[$IEND]
$AVARRAY[$IEND]=$VTMP
$IEND-=1
NEXT
RETURN 1
ENDFUNC
FUNC _ARRAYSEARCH(CONST BYREF $AVARRAY,$VVALUE,$ISTART=0,$IEND=0,$ICASE=0,$ICOMPARE=0,$IFORWARD=1,$ISUBITEM=-1)
IF NOT ISARRAY($AVARRAY)THEN RETURN SETERROR(1,0,-1)
IF UBOUND($AVARRAY,0)>2 OR UBOUND($AVARRAY,0)<1 THEN RETURN SETERROR(2,0,-1)
LOCAL $IUBOUND=UBOUND($AVARRAY)-1
IF $IUBOUND=-1 THEN RETURN SETERROR(3,0,-1)
IF $IEND<1 OR $IEND>$IUBOUND THEN $IEND=$IUBOUND
IF $ISTART<0 THEN $ISTART=0
IF $ISTART>$IEND THEN RETURN SETERROR(4,0,-1)
LOCAL $ISTEP=1
IF NOT $IFORWARD THEN
LOCAL $ITMP=$ISTART
$ISTART=$IEND
$IEND=$ITMP
$ISTEP=-1
ENDIF
LOCAL $ICOMPTYPE=FALSE
IF $ICOMPARE=2 THEN
$ICOMPARE=0
$ICOMPTYPE=TRUE
ENDIF
SWITCH UBOUND($AVARRAY,0)
CASE 1
IF NOT $ICOMPARE THEN
IF NOT $ICASE THEN
FOR $I=$ISTART TO $IEND STEP $ISTEP
IF $ICOMPTYPE AND VARGETTYPE($AVARRAY[$I])<>VARGETTYPE($VVALUE)THEN CONTINUELOOP
IF $AVARRAY[$I]=$VVALUE THEN RETURN $I
NEXT
ELSE
FOR $I=$ISTART TO $IEND STEP $ISTEP
IF $ICOMPTYPE AND VARGETTYPE($AVARRAY[$I])<>VARGETTYPE($VVALUE)THEN CONTINUELOOP
IF $AVARRAY[$I]==$VVALUE THEN RETURN $I
NEXT
ENDIF
ELSE
FOR $I=$ISTART TO $IEND STEP $ISTEP
IF $ICOMPARE=3 THEN
IF STRINGREGEXP($AVARRAY[$I],$VVALUE)THEN RETURN $I
ELSE
IF STRINGINSTR($AVARRAY[$I],$VVALUE,$ICASE)>0 THEN RETURN $I
ENDIF
NEXT
ENDIF
CASE 2
LOCAL $IUBOUNDSUB=UBOUND($AVARRAY,2)-1
IF $ISUBITEM>$IUBOUNDSUB THEN $ISUBITEM=$IUBOUNDSUB
IF $ISUBITEM<0 THEN
$ISUBITEM=0
ELSE
$IUBOUNDSUB=$ISUBITEM
ENDIF
FOR $J=$ISUBITEM TO $IUBOUNDSUB
IF NOT $ICOMPARE THEN
IF NOT $ICASE THEN
FOR $I=$ISTART TO $IEND STEP $ISTEP
IF $ICOMPTYPE AND VARGETTYPE($AVARRAY[$I][$J])<>VARGETTYPE($VVALUE)THEN CONTINUELOOP
IF $AVARRAY[$I][$J]=$VVALUE THEN RETURN $I
NEXT
ELSE
FOR $I=$ISTART TO $IEND STEP $ISTEP
IF $ICOMPTYPE AND VARGETTYPE($AVARRAY[$I][$J])<>VARGETTYPE($VVALUE)THEN CONTINUELOOP
IF $AVARRAY[$I][$J]==$VVALUE THEN RETURN $I
NEXT
ENDIF
ELSE
FOR $I=$ISTART TO $IEND STEP $ISTEP
IF $ICOMPARE=3 THEN
IF STRINGREGEXP($AVARRAY[$I][$J],$VVALUE)THEN RETURN $I
ELSE
IF STRINGINSTR($AVARRAY[$I][$J],$VVALUE,$ICASE)>0 THEN RETURN $I
ENDIF
NEXT
ENDIF
NEXT
CASE ELSE
RETURN SETERROR(7,0,-1)
ENDSWITCH
RETURN SETERROR(6,0,-1)
ENDFUNC
FUNC _ARRAYSORT(BYREF $AVARRAY,$IDESCENDING=0,$ISTART=0,$IEND=0,$ISUBITEM=0,$IPIVOT=0)
IF NOT ISARRAY($AVARRAY)THEN RETURN SETERROR(1,0,0)
LOCAL $IUBOUND=UBOUND($AVARRAY)-1
IF $IUBOUND=-1 THEN RETURN SETERROR(5,0,0)
IF $IEND=DEFAULT THEN $IEND=0
IF $IEND<1 OR $IEND>$IUBOUND OR $IEND=DEFAULT THEN $IEND=$IUBOUND
IF $ISTART<0 OR $ISTART=DEFAULT THEN $ISTART=0
IF $ISTART>$IEND THEN RETURN SETERROR(2,0,0)
IF $IDESCENDING=DEFAULT THEN $IDESCENDING=0
IF $IPIVOT=DEFAULT THEN $IPIVOT=0
IF $ISUBITEM=DEFAULT THEN $ISUBITEM=0
SWITCH UBOUND($AVARRAY,0)
CASE 1
IF $IPIVOT THEN
__ARRAYDUALPIVOTSORT($AVARRAY,$ISTART,$IEND)
ELSE
__ARRAYQUICKSORT1D($AVARRAY,$ISTART,$IEND)
ENDIF
IF $IDESCENDING THEN _ARRAYREVERSE($AVARRAY,$ISTART,$IEND)
CASE 2
IF $IPIVOT THEN RETURN SETERROR(6,0,0)
LOCAL $ISUBMAX=UBOUND($AVARRAY,2)-1
IF $ISUBITEM>$ISUBMAX THEN RETURN SETERROR(3,0,0)
IF $IDESCENDING THEN
$IDESCENDING=-1
ELSE
$IDESCENDING=1
ENDIF
__ARRAYQUICKSORT2D($AVARRAY,$IDESCENDING,$ISTART,$IEND,$ISUBITEM,$ISUBMAX)
CASE ELSE
RETURN SETERROR(4,0,0)
ENDSWITCH
RETURN 1
ENDFUNC
FUNC __ARRAYQUICKSORT1D(BYREF $AVARRAY,CONST BYREF $ISTART,CONST BYREF $IEND)
IF $IEND<=$ISTART THEN RETURN
LOCAL $VTMP
IF ($IEND-$ISTART)<15 THEN
LOCAL $VCUR
FOR $I=$ISTART+1 TO $IEND
$VTMP=$AVARRAY[$I]
IF ISNUMBER($VTMP)THEN
FOR $J=$I-1 TO $ISTART STEP -1
$VCUR=$AVARRAY[$J]
IF ($VTMP>=$VCUR AND ISNUMBER($VCUR))OR (NOT ISNUMBER($VCUR)AND STRINGCOMPARE($VTMP,$VCUR)>=0)THEN EXITLOOP
$AVARRAY[$J+1]=$VCUR
NEXT
ELSE
FOR $J=$I-1 TO $ISTART STEP -1
IF (STRINGCOMPARE($VTMP,$AVARRAY[$J])>=0)THEN EXITLOOP
$AVARRAY[$J+1]=$AVARRAY[$J]
NEXT
ENDIF
$AVARRAY[$J+1]=$VTMP
NEXT
RETURN
ENDIF
LOCAL $L=$ISTART,$R=$IEND,$VPIVOT=$AVARRAY[INT(($ISTART+$IEND)/2)],$FNUM=ISNUMBER($VPIVOT)
DO
IF $FNUM THEN
WHILE ($AVARRAY[$L]<$VPIVOT AND ISNUMBER($AVARRAY[$L]))OR (NOT ISNUMBER($AVARRAY[$L])AND STRINGCOMPARE($AVARRAY[$L],$VPIVOT)<0)
$L+=1
WEND
WHILE ($AVARRAY[$R]>$VPIVOT AND ISNUMBER($AVARRAY[$R]))OR (NOT ISNUMBER($AVARRAY[$R])AND STRINGCOMPARE($AVARRAY[$R],$VPIVOT)>0)
$R-=1
WEND
ELSE
WHILE (STRINGCOMPARE($AVARRAY[$L],$VPIVOT)<0)
$L+=1
WEND
WHILE (STRINGCOMPARE($AVARRAY[$R],$VPIVOT)>0)
$R-=1
WEND
ENDIF
IF $L<=$R THEN
$VTMP=$AVARRAY[$L]
$AVARRAY[$L]=$AVARRAY[$R]
$AVARRAY[$R]=$VTMP
$L+=1
$R-=1
ENDIF
UNTIL $L>$R
__ARRAYQUICKSORT1D($AVARRAY,$ISTART,$R)
__ARRAYQUICKSORT1D($AVARRAY,$L,$IEND)
ENDFUNC
FUNC __ARRAYQUICKSORT2D(BYREF $AVARRAY,CONST BYREF $ISTEP,CONST BYREF $ISTART,CONST BYREF $IEND,CONST BYREF $ISUBITEM,CONST BYREF $ISUBMAX)
IF $IEND<=$ISTART THEN RETURN
LOCAL $VTMP,$L=$ISTART,$R=$IEND,$VPIVOT=$AVARRAY[INT(($ISTART+$IEND)/2)][$ISUBITEM],$FNUM=ISNUMBER($VPIVOT)
DO
IF $FNUM THEN
WHILE ($ISTEP*($AVARRAY[$L][$ISUBITEM]-$VPIVOT)<0 AND ISNUMBER($AVARRAY[$L][$ISUBITEM]))OR (NOT ISNUMBER($AVARRAY[$L][$ISUBITEM])AND $ISTEP*STRINGCOMPARE($AVARRAY[$L][$ISUBITEM],$VPIVOT)<0)
$L+=1
WEND
WHILE ($ISTEP*($AVARRAY[$R][$ISUBITEM]-$VPIVOT)>0 AND ISNUMBER($AVARRAY[$R][$ISUBITEM]))OR (NOT ISNUMBER($AVARRAY[$R][$ISUBITEM])AND $ISTEP*STRINGCOMPARE($AVARRAY[$R][$ISUBITEM],$VPIVOT)>0)
$R-=1
WEND
ELSE
WHILE ($ISTEP*STRINGCOMPARE($AVARRAY[$L][$ISUBITEM],$VPIVOT)<0)
$L+=1
WEND
WHILE ($ISTEP*STRINGCOMPARE($AVARRAY[$R][$ISUBITEM],$VPIVOT)>0)
$R-=1
WEND
ENDIF
IF $L<=$R THEN
FOR $I=0 TO $ISUBMAX
$VTMP=$AVARRAY[$L][$I]
$AVARRAY[$L][$I]=$AVARRAY[$R][$I]
$AVARRAY[$R][$I]=$VTMP
NEXT
$L+=1
$R-=1
ENDIF
UNTIL $L>$R
__ARRAYQUICKSORT2D($AVARRAY,$ISTEP,$ISTART,$R,$ISUBITEM,$ISUBMAX)
__ARRAYQUICKSORT2D($AVARRAY,$ISTEP,$L,$IEND,$ISUBITEM,$ISUBMAX)
ENDFUNC
FUNC __ARRAYDUALPIVOTSORT(BYREF $AARRAY,$IPIVOT_LEFT,$IPIVOT_RIGHT,$FLEFTMOST=TRUE )
IF $IPIVOT_LEFT>$IPIVOT_RIGHT THEN RETURN
LOCAL $ILENGTH=$IPIVOT_RIGHT-$IPIVOT_LEFT+1
LOCAL $I,$J,$K,$AI,$AK,$A1,$A2,$LAST
IF $ILENGTH<45 THEN
IF $FLEFTMOST THEN
$I=$IPIVOT_LEFT
WHILE $I<$IPIVOT_RIGHT
$J=$I
$AI=$AARRAY[$I+1]
WHILE $AI<$AARRAY[$J]
$AARRAY[$J+1]=$AARRAY[$J]
$J-=1
IF $J+1=$IPIVOT_LEFT THEN EXITLOOP
WEND
$AARRAY[$J+1]=$AI
$I+=1
WEND
ELSE
WHILE 1
IF $IPIVOT_LEFT>=$IPIVOT_RIGHT THEN RETURN 1
$IPIVOT_LEFT+=1
IF $AARRAY[$IPIVOT_LEFT]<$AARRAY[$IPIVOT_LEFT-1]THEN EXITLOOP
WEND
WHILE 1
$K=$IPIVOT_LEFT
$IPIVOT_LEFT+=1
IF $IPIVOT_LEFT>$IPIVOT_RIGHT THEN EXITLOOP
$A1=$AARRAY[$K]
$A2=$AARRAY[$IPIVOT_LEFT]
IF $A1<$A2 THEN
$A2=$A1
$A1=$AARRAY[$IPIVOT_LEFT]
ENDIF
$K-=1
WHILE $A1<$AARRAY[$K]
$AARRAY[$K+2]=$AARRAY[$K]
$K-=1
WEND
$AARRAY[$K+2]=$A1
WHILE $A2<$AARRAY[$K]
$AARRAY[$K+1]=$AARRAY[$K]
$K-=1
WEND
$AARRAY[$K+1]=$A2
$IPIVOT_LEFT+=1
WEND
$LAST=$AARRAY[$IPIVOT_RIGHT]
$IPIVOT_RIGHT-=1
WHILE $LAST<$AARRAY[$IPIVOT_RIGHT]
$AARRAY[$IPIVOT_RIGHT+1]=$AARRAY[$IPIVOT_RIGHT]
$IPIVOT_RIGHT-=1
WEND
$AARRAY[$IPIVOT_RIGHT+1]=$LAST
ENDIF
RETURN 1
ENDIF
LOCAL $ISEVENTH=BITSHIFT($ILENGTH,3)+BITSHIFT($ILENGTH,6)+1
LOCAL $E1,$E2,$E3,$E4,$E5,$T
$E3=CEILING(($IPIVOT_LEFT+$IPIVOT_RIGHT)/2)
$E2=$E3-$ISEVENTH
$E1=$E2-$ISEVENTH
$E4=$E3+$ISEVENTH
$E5=$E4+$ISEVENTH
IF $AARRAY[$E2]<$AARRAY[$E1]THEN
$T=$AARRAY[$E2]
$AARRAY[$E2]=$AARRAY[$E1]
$AARRAY[$E1]=$T
ENDIF
IF $AARRAY[$E3]<$AARRAY[$E2]THEN
$T=$AARRAY[$E3]
$AARRAY[$E3]=$AARRAY[$E2]
$AARRAY[$E2]=$T
IF $T<$AARRAY[$E1]THEN
$AARRAY[$E2]=$AARRAY[$E1]
$AARRAY[$E1]=$T
ENDIF
ENDIF
IF $AARRAY[$E4]<$AARRAY[$E3]THEN
$T=$AARRAY[$E4]
$AARRAY[$E4]=$AARRAY[$E3]
$AARRAY[$E3]=$T
IF $T<$AARRAY[$E2]THEN
$AARRAY[$E3]=$AARRAY[$E2]
$AARRAY[$E2]=$T
IF $T<$AARRAY[$E1]THEN
$AARRAY[$E2]=$AARRAY[$E1]
$AARRAY[$E1]=$T
ENDIF
ENDIF
ENDIF
IF $AARRAY[$E5]<$AARRAY[$E4]THEN
$T=$AARRAY[$E5]
$AARRAY[$E5]=$AARRAY[$E4]
$AARRAY[$E4]=$T
IF $T<$AARRAY[$E3]THEN
$AARRAY[$E4]=$AARRAY[$E3]
$AARRAY[$E3]=$T
IF $T<$AARRAY[$E2]THEN
$AARRAY[$E3]=$AARRAY[$E2]
$AARRAY[$E2]=$T
IF $T<$AARRAY[$E1]THEN
$AARRAY[$E2]=$AARRAY[$E1]
$AARRAY[$E1]=$T
ENDIF
ENDIF
ENDIF
ENDIF
LOCAL $ILESS=$IPIVOT_LEFT
LOCAL $IGREATER=$IPIVOT_RIGHT
IF (($AARRAY[$E1]<>$AARRAY[$E2])AND ($AARRAY[$E2]<>$AARRAY[$E3])AND ($AARRAY[$E3]<>$AARRAY[$E4])AND ($AARRAY[$E4]<>$AARRAY[$E5]))THEN
LOCAL $IPIVOT_1=$AARRAY[$E2]
LOCAL $IPIVOT_2=$AARRAY[$E4]
$AARRAY[$E2]=$AARRAY[$IPIVOT_LEFT]
$AARRAY[$E4]=$AARRAY[$IPIVOT_RIGHT]
DO
$ILESS+=1
UNTIL $AARRAY[$ILESS]>=$IPIVOT_1
DO
$IGREATER-=1
UNTIL $AARRAY[$IGREATER]<=$IPIVOT_2
$K=$ILESS
WHILE $K<=$IGREATER
$AK=$AARRAY[$K]
IF $AK<$IPIVOT_1 THEN
$AARRAY[$K]=$AARRAY[$ILESS]
$AARRAY[$ILESS]=$AK
$ILESS+=1
ELSEIF $AK>$IPIVOT_2 THEN
WHILE $AARRAY[$IGREATER]>$IPIVOT_2
$IGREATER-=1
IF $IGREATER+1=$K THEN EXITLOOP 2
WEND
IF $AARRAY[$IGREATER]<$IPIVOT_1 THEN
$AARRAY[$K]=$AARRAY[$ILESS]
$AARRAY[$ILESS]=$AARRAY[$IGREATER]
$ILESS+=1
ELSE
$AARRAY[$K]=$AARRAY[$IGREATER]
ENDIF
$AARRAY[$IGREATER]=$AK
$IGREATER-=1
ENDIF
$K+=1
WEND
$AARRAY[$IPIVOT_LEFT]=$AARRAY[$ILESS-1]
$AARRAY[$ILESS-1]=$IPIVOT_1
$AARRAY[$IPIVOT_RIGHT]=$AARRAY[$IGREATER+1]
$AARRAY[$IGREATER+1]=$IPIVOT_2
__ARRAYDUALPIVOTSORT($AARRAY,$IPIVOT_LEFT,$ILESS-2,TRUE )
__ARRAYDUALPIVOTSORT($AARRAY,$IGREATER+2,$IPIVOT_RIGHT,FALSE )
IF ($ILESS<$E1)AND ($E5<$IGREATER)THEN
WHILE $AARRAY[$ILESS]=$IPIVOT_1
$ILESS+=1
WEND
WHILE $AARRAY[$IGREATER]=$IPIVOT_2
$IGREATER-=1
WEND
$K=$ILESS
WHILE $K<=$IGREATER
$AK=$AARRAY[$K]
IF $AK=$IPIVOT_1 THEN
$AARRAY[$K]=$AARRAY[$ILESS]
$AARRAY[$ILESS]=$AK
$ILESS+=1
ELSEIF $AK=$IPIVOT_2 THEN
WHILE $AARRAY[$IGREATER]=$IPIVOT_2
$IGREATER-=1
IF $IGREATER+1=$K THEN EXITLOOP 2
WEND
IF $AARRAY[$IGREATER]=$IPIVOT_1 THEN
$AARRAY[$K]=$AARRAY[$ILESS]
$AARRAY[$ILESS]=$IPIVOT_1
$ILESS+=1
ELSE
$AARRAY[$K]=$AARRAY[$IGREATER]
ENDIF
$AARRAY[$IGREATER]=$AK
$IGREATER-=1
ENDIF
$K+=1
WEND
ENDIF
__ARRAYDUALPIVOTSORT($AARRAY,$ILESS,$IGREATER,FALSE )
ELSE
LOCAL $IPIVOT=$AARRAY[$E3]
$K=$ILESS
WHILE $K<=$IGREATER
IF $AARRAY[$K]=$IPIVOT THEN
$K+=1
CONTINUELOOP
ENDIF
$AK=$AARRAY[$K]
IF $AK<$IPIVOT THEN
$AARRAY[$K]=$AARRAY[$ILESS]
$AARRAY[$ILESS]=$AK
$ILESS+=1
ELSE
WHILE $AARRAY[$IGREATER]>$IPIVOT
$IGREATER-=1
WEND
IF $AARRAY[$IGREATER]<$IPIVOT THEN
$AARRAY[$K]=$AARRAY[$ILESS]
$AARRAY[$ILESS]=$AARRAY[$IGREATER]
$ILESS+=1
ELSE
$AARRAY[$K]=$IPIVOT
ENDIF
$AARRAY[$IGREATER]=$AK
$IGREATER-=1
ENDIF
$K+=1
WEND
__ARRAYDUALPIVOTSORT($AARRAY,$IPIVOT_LEFT,$ILESS-1,TRUE )
__ARRAYDUALPIVOTSORT($AARRAY,$IGREATER+1,$IPIVOT_RIGHT,FALSE )
ENDIF
ENDFUNC
FUNC _ARRAYSWAP(BYREF $VITEM1,BYREF $VITEM2)
LOCAL $VTMP=$VITEM1
$VITEM1=$VITEM2
$VITEM2=$VTMP
ENDFUNC
FUNC _ARRAYTOCLIP(CONST BYREF $AVARRAY,$ISTART=0,$IEND=0)
LOCAL $SRESULT=_ARRAYTOSTRING($AVARRAY,@CR,$ISTART,$IEND)
IF @ERROR THEN RETURN SETERROR(@ERROR,0,0)
IF CLIPPUT($SRESULT)THEN RETURN 1
RETURN SETERROR(-1,0,0)
ENDFUNC
FUNC _ARRAYTOSTRING(CONST BYREF $AVARRAY,$SDELIM="|",$ISTART=0,$IEND=0)
IF NOT ISARRAY($AVARRAY)THEN RETURN SETERROR(1,0,"")
IF UBOUND($AVARRAY,0)<>1 THEN RETURN SETERROR(3,0,"")
IF NOT UBOUND($AVARRAY)THEN RETURN SETERROR(4,0,"")
LOCAL $SRESULT,$IUBOUND=UBOUND($AVARRAY)-1
IF $IEND<1 OR $IEND>$IUBOUND THEN $IEND=$IUBOUND
IF $ISTART<0 THEN $ISTART=0
IF $ISTART>$IEND THEN RETURN SETERROR(2,0,"")
FOR $I=$ISTART TO $IEND
$SRESULT&=$AVARRAY[$I]&$SDELIM
NEXT
RETURN STRINGTRIMRIGHT($SRESULT,STRINGLEN($SDELIM))
ENDFUNC
FUNC _ARRAYTRANSPOSE(BYREF $AVARRAY)
IF UBOUND($AVARRAY,0)<>2 THEN RETURN SETERROR(1,0,0)
LOCAL $VELEMENT=0,$IDIM_1=UBOUND($AVARRAY,1),$IDIM_2=UBOUND($AVARRAY,2),$IDIM_MAX=($IDIM_1>$IDIM_2)?$IDIM_1:$IDIM_2
IF $IDIM_MAX<=4096 THEN
REDIM $AVARRAY[$IDIM_MAX][$IDIM_MAX]
FOR $I=0 TO $IDIM_MAX-2
FOR $J=$I+1 TO $IDIM_MAX-1
$VELEMENT=$AVARRAY[$I][$J]
$AVARRAY[$I][$J]=$AVARRAY[$J][$I]
$AVARRAY[$J][$I]=$VELEMENT
NEXT
NEXT
REDIM $AVARRAY[$IDIM_2][$IDIM_1]
ELSE
LOCAL $ATEMP[$IDIM_2][$IDIM_1]
FOR $I=0 TO $IDIM_1-1
FOR $J=0 TO $IDIM_2-1
$ATEMP[$J][$I]=$AVARRAY[$I][$J]
NEXT
NEXT
REDIM $AVARRAY[$IDIM_2][$IDIM_1]
$AVARRAY=$ATEMP
ENDIF
RETURN 1
ENDFUNC
FUNC _ARRAYTRIM(BYREF $AVARRAY,$ITRIMNUM,$IDIRECTION=0,$ISTART=0,$IEND=0)
IF NOT ISARRAY($AVARRAY)THEN RETURN SETERROR(1,0,0)
IF UBOUND($AVARRAY,0)<>1 THEN RETURN SETERROR(2,0,0)
IF NOT UBOUND($AVARRAY)THEN RETURN SETERROR(3,0,0)
LOCAL $IUBOUND=UBOUND($AVARRAY)-1
IF $IEND<1 OR $IEND>$IUBOUND THEN $IEND=$IUBOUND
IF $ISTART<0 THEN $ISTART=0
IF $ISTART>$IEND THEN RETURN SETERROR(5,0,0)
IF $IDIRECTION THEN
FOR $I=$ISTART TO $IEND
$AVARRAY[$I]=STRINGTRIMRIGHT($AVARRAY[$I],$ITRIMNUM)
NEXT
ELSE
FOR $I=$ISTART TO $IEND
$AVARRAY[$I]=STRINGTRIMLEFT($AVARRAY[$I],$ITRIMNUM)
NEXT
ENDIF
RETURN 1
ENDFUNC
FUNC _ARRAYUNIQUE(CONST BYREF $AARRAY,$ICOLUMN=DEFAULT ,$IBASE=DEFAULT ,$ICASE=DEFAULT ,$IFLAGS=DEFAULT )
IF $ICOLUMN=DEFAULT THEN $ICOLUMN=1
IF $IBASE=DEFAULT THEN $IBASE=0
IF $ICASE=DEFAULT THEN $ICASE=0
IF $IFLAGS=DEFAULT THEN $IFLAGS=1
IF UBOUND($AARRAY)=0 THEN RETURN SETERROR(1,0,0)
IF $IBASE<0 OR $IBASE>1 OR (NOT ISINT($IBASE))THEN RETURN SETERROR(2,0,0)
IF $ICASE<0 OR $ICASE>1 OR (NOT ISINT($ICASE))THEN RETURN SETERROR(2,0,0)
IF $IFLAGS<0 OR $IFLAGS>1 OR (NOT ISINT($IFLAGS))THEN RETURN SETERROR(4,0,0)
LOCAL $IDIMS=UBOUND($AARRAY,0),$INUMCOLUMNS=UBOUND($AARRAY,2)
IF $IDIMS>2 THEN RETURN SETERROR(3,0,0)
IF ($ICOLUMN<1)OR ($INUMCOLUMNS=0 AND ($ICOLUMN-1>$INUMCOLUMNS))OR ($INUMCOLUMNS>0 AND ($ICOLUMN>$INUMCOLUMNS))THEN RETURN SETERROR(3,0,0)
$ICOLUMN-=1
LOCAL $OD=OBJCREATE("Scripting.Dictionary")
$OD.CompareMode=NUMBER(NOT $ICASE)
LOCAL $VELEM
FOR $I=$IBASE TO UBOUND($AARRAY)-1
IF $IDIMS=1 THEN
$VELEM=$AARRAY[$I]
ELSE
$VELEM=$AARRAY[$I][$ICOLUMN]
ENDIF
$OD.Item($VELEM)
NEXT
IF BITAND($IFLAGS,1)=1 THEN
LOCAL $ATEMP=$OD.Keys()
_ARRAYINSERT($ATEMP,0,$OD.Count)
RETURN $ATEMP
ELSE
RETURN $OD.Keys()
ENDIF
ENDFUNC
FUNC __ARRAY_EXETERINTERNAL(BYREF $AVARRAY,$ISTART,$ISIZE,$SDELIM,BYREF $AIDX,BYREF $ARESULT,BYREF $ICOUNT)
IF $ISTART==$ISIZE-1 THEN
FOR $I=0 TO $ISIZE-1
$ARESULT[$ICOUNT]&=$AVARRAY[$AIDX[$I]]&$SDELIM
NEXT
IF $SDELIM<>"" THEN $ARESULT[$ICOUNT]=STRINGTRIMRIGHT($ARESULT[$ICOUNT],1)
$ICOUNT+=1
ELSE
LOCAL $ITEMP
FOR $I=$ISTART TO $ISIZE-1
$ITEMP=$AIDX[$I]
$AIDX[$I]=$AIDX[$ISTART]
$AIDX[$ISTART]=$ITEMP
__ARRAY_EXETERINTERNAL($AVARRAY,$ISTART+1,$ISIZE,$SDELIM,$AIDX,$ARESULT,$ICOUNT)
$AIDX[$ISTART]=$AIDX[$I]
$AIDX[$I]=$ITEMP
NEXT
ENDIF
ENDFUNC
FUNC __ARRAY_COMBINATIONS($IN,$IR)
LOCAL $I_TOTAL=1
FOR $I=$IR TO 1 STEP -1
$I_TOTAL*=($IN/$I)
$IN-=1
NEXT
RETURN ROUND($I_TOTAL)
ENDFUNC
FUNC __ARRAY_GETNEXT($IN,$IR,BYREF $ILEFT,$ITOTAL,BYREF $AIDX)
IF $ILEFT==$ITOTAL THEN
$ILEFT-=1
RETURN
ENDIF
LOCAL $I=$IR-1
WHILE $AIDX[$I]==$IN-$IR+$I
$I-=1
WEND
$AIDX[$I]+=1
FOR $J=$I+1 TO $IR-1
$AIDX[$J]=$AIDX[$I]+$J-$I
NEXT
$ILEFT-=1
ENDFUNC
GLOBAL CONST $FC_NOOVERWRITE=0
GLOBAL CONST $FC_OVERWRITE=1
GLOBAL CONST $FC_CREATEPATH=8
GLOBAL CONST $FT_MODIFIED=0
GLOBAL CONST $FT_CREATED=1
GLOBAL CONST $FT_ACCESSED=2
GLOBAL CONST $FO_READ=0
GLOBAL CONST $FO_APPEND=1
GLOBAL CONST $FO_OVERWRITE=2
GLOBAL CONST $FO_CREATEPATH=8
GLOBAL CONST $FO_BINARY=16
GLOBAL CONST $FO_UNICODE=32
GLOBAL CONST $FO_UTF16_LE=32
GLOBAL CONST $FO_UTF16_BE=64
GLOBAL CONST $FO_UTF8=128
GLOBAL CONST $FO_UTF8_NOBOM=256
GLOBAL CONST $FO_UTF8_FULL=16384
GLOBAL CONST $EOF=-1
GLOBAL CONST $FD_FILEMUSTEXIST=1
GLOBAL CONST $FD_PATHMUSTEXIST=2
GLOBAL CONST $FD_MULTISELECT=4
GLOBAL CONST $FD_PROMPTCREATENEW=8
GLOBAL CONST $FD_PROMPTOVERWRITE=16
GLOBAL CONST $CREATE_NEW=1
GLOBAL CONST $CREATE_ALWAYS=2
GLOBAL CONST $OPEN_EXISTING=3
GLOBAL CONST $OPEN_ALWAYS=4
GLOBAL CONST $TRUNCATE_EXISTING=5
GLOBAL CONST $INVALID_SET_FILE_POINTER=-1
GLOBAL CONST $FILE_BEGIN=0
GLOBAL CONST $FILE_CURRENT=1
GLOBAL CONST $FILE_END=2
GLOBAL CONST $FILE_ATTRIBUTE_READONLY=1
GLOBAL CONST $FILE_ATTRIBUTE_HIDDEN=2
GLOBAL CONST $FILE_ATTRIBUTE_SYSTEM=4
GLOBAL CONST $FILE_ATTRIBUTE_DIRECTORY=16
GLOBAL CONST $FILE_ATTRIBUTE_ARCHIVE=32
GLOBAL CONST $FILE_ATTRIBUTE_DEVICE=64
GLOBAL CONST $FILE_ATTRIBUTE_NORMAL=128
GLOBAL CONST $FILE_ATTRIBUTE_TEMPORARY=256
GLOBAL CONST $FILE_ATTRIBUTE_SPARSE_FILE=512
GLOBAL CONST $FILE_ATTRIBUTE_REPARSE_POINT=1024
GLOBAL CONST $FILE_ATTRIBUTE_COMPRESSED=2048
GLOBAL CONST $FILE_ATTRIBUTE_OFFLINE=4096
GLOBAL CONST $FILE_ATTRIBUTE_NOT_CONTENT_INDEXED=8192
GLOBAL CONST $FILE_ATTRIBUTE_ENCRYPTED=16384
GLOBAL CONST $FILE_SHARE_READ=1
GLOBAL CONST $FILE_SHARE_WRITE=2
GLOBAL CONST $FILE_SHARE_DELETE=4
GLOBAL CONST $FILE_SHARE_READWRITE=BITOR($FILE_SHARE_READ,$FILE_SHARE_WRITE)
GLOBAL CONST $FILE_SHARE_ANY=BITOR($FILE_SHARE_READ,$FILE_SHARE_WRITE,$FILE_SHARE_DELETE)
GLOBAL CONST $GENERIC_ALL=268435456
GLOBAL CONST $GENERIC_EXECUTE=536870912
GLOBAL CONST $GENERIC_WRITE=1073741824
GLOBAL CONST $GENERIC_READ=-2147483648
GLOBAL CONST $GENERIC_READWRITE=BITOR($GENERIC_READ,$GENERIC_WRITE)
GLOBAL CONST $STR_NOCASESENSE=0
GLOBAL CONST $STR_CASESENSE=1
GLOBAL CONST $STR_NOCASESENSEBASIC=2
GLOBAL CONST $STR_STRIPLEADING=1
GLOBAL CONST $STR_STRIPTRAILING=2
GLOBAL CONST $STR_STRIPSPACES=4
GLOBAL CONST $STR_STRIPALL=8
GLOBAL CONST $STR_CHRSPLIT=0
GLOBAL CONST $STR_ENTIRESPLIT=1
GLOBAL CONST $STR_NOCOUNT=2
FUNC _FILECOUNTLINES($SFILEPATH)
LOCAL $HFILEOPEN=FILEOPEN($SFILEPATH,$FO_READ)
IF $HFILEOPEN=-1 THEN RETURN SETERROR(1,0,0)
LOCAL $SFILEREAD=STRINGSTRIPWS(FILEREAD($HFILEOPEN),$STR_STRIPTRAILING)
FILECLOSE($HFILEOPEN)
RETURN UBOUND(STRINGREGEXP($SFILEREAD,"(*BSR_ANYCRLF)\R",3))+1-INT($SFILEREAD="")
ENDFUNC
FUNC _FILECREATE($SFILEPATH)
LOCAL $HFILEOPEN=FILEOPEN($SFILEPATH,$FO_OVERWRITE)
IF $HFILEOPEN=-1 THEN RETURN SETERROR(1,0,0)
LOCAL $IFILEWRITE=FILEWRITE($HFILEOPEN,"")
FILECLOSE($HFILEOPEN)
IF NOT $IFILEWRITE THEN RETURN SETERROR(2,0,0)
RETURN 1
ENDFUNC
FUNC _FILELISTTOARRAY($SFILEPATH,$SFILTER="*",$IFLAG=0,$FRETURNPATH=FALSE )
LOCAL $SDELIMITER="|",$SFILELIST="",$SFILENAME="",$SFULLPATH=""
$SFILEPATH=STRINGREGEXPREPLACE($SFILEPATH,"[\\/]+$","")&"\"
IF $IFLAG=DEFAULT THEN $IFLAG=0
IF $FRETURNPATH THEN $SFULLPATH=$SFILEPATH
IF $SFILTER=DEFAULT THEN $SFILTER="*"
IF NOT FILEEXISTS($SFILEPATH)THEN RETURN SETERROR(1,0,0)
IF STRINGREGEXP($SFILTER,"[\\/:><\|]|(?s)^\s*$")THEN RETURN SETERROR(2,0,0)
IF NOT ($IFLAG=0 OR $IFLAG=1 OR $IFLAG=2)THEN RETURN SETERROR(3,0,0)
LOCAL $HSEARCH=FILEFINDFIRSTFILE($SFILEPATH&$SFILTER)
IF @ERROR THEN RETURN SETERROR(4,0,0)
WHILE 1
$SFILENAME=FILEFINDNEXTFILE($HSEARCH)
IF @ERROR THEN EXITLOOP
IF ($IFLAG+@EXTENDED=2)THEN CONTINUELOOP
$SFILELIST&=$SDELIMITER&$SFULLPATH&$SFILENAME
WEND
FILECLOSE($HSEARCH)
IF $SFILELIST="" THEN RETURN SETERROR(4,0,0)
RETURN STRINGSPLIT(STRINGTRIMLEFT($SFILELIST,1),$SDELIMITER)
ENDFUNC
FUNC _FILELISTTOARRAYREC($SINITIALPATH,$SMASK="*",$IRETURN=0,$IRECUR=0,$ISORT=0,$IRETURNPATH=1)
LOCAL $ASRETURNLIST[100]=[0],$ASFILEMATCHLIST[100]=[0],$ASROOTFILEMATCHLIST[100]=[0],$ASFOLDERMATCHLIST[100]=[0],$ASFOLDERSEARCHLIST[100]=[1]
LOCAL $SINCLUDE_LIST="*",$SEXCLUDE_LIST,$SEXCLUDE_LIST_FOLDER,$SINCLUDE_FILE_MASK=".+",$SEXCLUDE_FILE_MASK=":",$SINCLUDE_FOLDER_MASK=".+",$SEXCLUDE_FOLDER_MASK=":"
LOCAL $SFOLDERSLASH="",$IMAXLEVEL,$HSEARCH,$FFOLDER,$SRETPATH="",$SCURRENTPATH,$SNAME,$IATTRIBS,$IHIDE_HS=0,$IHIDE_LINK=0,$FLONGPATH=FALSE
LOCAL $ASFOLDERFILESECTIONLIST[100][2]=[[0,0]],$SFOLDERTOFIND,$IFILESECTIONSTARTINDEX,$IFILESECTIONENDINDEX
IF STRINGLEFT($SINITIALPATH,4)=="\\?\" THEN
$FLONGPATH=TRUE
ENDIF
IF NOT FILEEXISTS($SINITIALPATH)THEN RETURN SETERROR(1,1,"")
IF STRINGRIGHT($SINITIALPATH,1)="\" THEN
$SFOLDERSLASH="\"
ELSE
$SINITIALPATH=$SINITIALPATH&"\"
ENDIF
$ASFOLDERSEARCHLIST[1]=$SINITIALPATH
IF $SMASK=DEFAULT THEN $SMASK="*"
IF $IRETURN=DEFAULT THEN $IRETURN=0
IF $IRECUR=DEFAULT THEN $IRECUR=0
IF $ISORT=DEFAULT THEN $ISORT=0
IF $IRETURNPATH=DEFAULT THEN $IRETURNPATH=1
IF BITAND($IRETURN,4)THEN
$IHIDE_HS+=2
$IRETURN-=4
ENDIF
IF BITAND($IRETURN,8)THEN
$IHIDE_HS+=4
$IRETURN-=8
ENDIF
IF BITAND($IRETURN,16)THEN
$IHIDE_LINK=1024
$IRETURN-=16
ENDIF
IF $IRECUR>1 OR NOT ISINT($IRECUR)THEN RETURN SETERROR(1,6,"")
IF $IRECUR<0 THEN
STRINGREPLACE($SINITIALPATH,"\","",0,$STR_NOCASESENSEBASIC)
$IMAXLEVEL=@EXTENDED-$IRECUR
ENDIF
LOCAL $AMASKSPLIT=STRINGSPLIT($SMASK,"|")
SWITCH $AMASKSPLIT[0]
CASE 3
$SEXCLUDE_LIST_FOLDER=$AMASKSPLIT[3]
CONTINUECASE
CASE 2
$SEXCLUDE_LIST=$AMASKSPLIT[2]
CONTINUECASE
CASE 1
$SINCLUDE_LIST=$AMASKSPLIT[1]
ENDSWITCH
IF $SINCLUDE_LIST<>"*" THEN
IF NOT __FLTAR_LISTTOMASK($SINCLUDE_FILE_MASK,$SINCLUDE_LIST)THEN RETURN SETERROR(1,2,"")
ENDIF
SWITCH $IRETURN
CASE 0
SWITCH $IRECUR
CASE 0
$SINCLUDE_FOLDER_MASK=$SINCLUDE_FILE_MASK
ENDSWITCH
CASE 2
$SINCLUDE_FOLDER_MASK=$SINCLUDE_FILE_MASK
ENDSWITCH
IF $SEXCLUDE_LIST<>"" THEN
IF NOT __FLTAR_LISTTOMASK($SEXCLUDE_FILE_MASK,$SEXCLUDE_LIST)THEN RETURN SETERROR(1,3,"")
ENDIF
IF $IRECUR THEN
IF $SEXCLUDE_LIST_FOLDER THEN
IF NOT __FLTAR_LISTTOMASK($SEXCLUDE_FOLDER_MASK,$SEXCLUDE_LIST_FOLDER)THEN RETURN SETERROR(1,4,"")
ENDIF
IF $IRETURN=2 THEN
$SEXCLUDE_FOLDER_MASK=$SEXCLUDE_FILE_MASK
ENDIF
ELSE
$SEXCLUDE_FOLDER_MASK=$SEXCLUDE_FILE_MASK
ENDIF
IF NOT ($IRETURN=0 OR $IRETURN=1 OR $IRETURN=2)THEN RETURN SETERROR(1,5,"")
IF NOT ($ISORT=0 OR $ISORT=1 OR $ISORT=2)THEN RETURN SETERROR(1,7,"")
IF NOT ($IRETURNPATH=0 OR $IRETURNPATH=1 OR $IRETURNPATH=2)THEN RETURN SETERROR(1,8,"")
IF $IHIDE_HS OR $IHIDE_LINK THEN
LOCAL $TFILE_DATA=DLLSTRUCTCREATE("struct;align 4;dword FileAttributes;uint64 CreationTime;uint64 LastAccessTime;uint64 LastWriteTime;"&"dword FileSizeHigh;dword FileSizeLow;dword Reserved0;dword Reserved1;wchar FileName[260];wchar AlternateFileName[14];endstruct")
LOCAL $PFILE_DATA=DLLSTRUCTGETPTR($TFILE_DATA),$HDLL=DLLOPEN("kernel32.dll"),$ADLL_RET
ENDIF
WHILE $ASFOLDERSEARCHLIST[0]>0
$SCURRENTPATH=$ASFOLDERSEARCHLIST[$ASFOLDERSEARCHLIST[0]]
$ASFOLDERSEARCHLIST[0]-=1
SWITCH $IRETURNPATH
CASE 1
$SRETPATH=STRINGREPLACE($SCURRENTPATH,$SINITIALPATH,"")
CASE 2
IF $FLONGPATH THEN
$SRETPATH=STRINGTRIMLEFT($SCURRENTPATH,4)
ELSE
$SRETPATH=$SCURRENTPATH
ENDIF
ENDSWITCH
IF $IHIDE_HS OR $IHIDE_LINK THEN
$ADLL_RET=DLLCALL($HDLL,"ptr","FindFirstFileW","wstr",$SCURRENTPATH&"*","ptr",$PFILE_DATA)
IF @ERROR OR NOT $ADLL_RET[0]THEN
CONTINUELOOP
ENDIF
$HSEARCH=$ADLL_RET[0]
ELSE
$HSEARCH=FILEFINDFIRSTFILE($SCURRENTPATH&"*")
IF $HSEARCH=-1 THEN
CONTINUELOOP
ENDIF
ENDIF
IF $IRETURN=0 AND $ISORT AND $IRETURNPATH THEN
__FLTAR_ADDTOLIST($ASFOLDERFILESECTIONLIST,$SRETPATH,$ASFILEMATCHLIST[0]+1)
ENDIF
WHILE 1
IF $IHIDE_HS OR $IHIDE_LINK THEN
$ADLL_RET=DLLCALL($HDLL,"int","FindNextFileW","ptr",$HSEARCH,"ptr",$PFILE_DATA)
IF @ERROR OR NOT $ADLL_RET[0]THEN
EXITLOOP
ENDIF
$SNAME=DLLSTRUCTGETDATA($TFILE_DATA,"FileName")
IF $SNAME=".." THEN
CONTINUELOOP
ENDIF
$IATTRIBS=DLLSTRUCTGETDATA($TFILE_DATA,"FileAttributes")
IF $IHIDE_HS AND BITAND($IATTRIBS,$IHIDE_HS)THEN
CONTINUELOOP
ENDIF
IF $IHIDE_LINK AND BITAND($IATTRIBS,$IHIDE_LINK)THEN
CONTINUELOOP
ENDIF
$FFOLDER=0
IF BITAND($IATTRIBS,16)THEN
$FFOLDER=1
ENDIF
ELSE
$SNAME=FILEFINDNEXTFILE($HSEARCH)
IF @ERROR THEN
EXITLOOP
ENDIF
$FFOLDER=@EXTENDED
ENDIF
IF $FFOLDER THEN
SELECT
CASE $IRECUR<0
STRINGREPLACE($SCURRENTPATH,"\","",0,$STR_NOCASESENSEBASIC)
IF @EXTENDED<$IMAXLEVEL THEN
CONTINUECASE
ENDIF
CASE $IRECUR=1
IF NOT STRINGREGEXP($SNAME,$SEXCLUDE_FOLDER_MASK)THEN
__FLTAR_ADDTOLIST($ASFOLDERSEARCHLIST,$SCURRENTPATH&$SNAME&"\")
ENDIF
ENDSELECT
ENDIF
IF $ISORT THEN
IF $FFOLDER THEN
IF STRINGREGEXP($SNAME,$SINCLUDE_FOLDER_MASK)AND NOT STRINGREGEXP($SNAME,$SEXCLUDE_FOLDER_MASK)THEN
__FLTAR_ADDTOLIST($ASFOLDERMATCHLIST,$SRETPATH&$SNAME&$SFOLDERSLASH)
ENDIF
ELSE
IF STRINGREGEXP($SNAME,$SINCLUDE_FILE_MASK)AND NOT STRINGREGEXP($SNAME,$SEXCLUDE_FILE_MASK)THEN
IF $SCURRENTPATH=$SINITIALPATH THEN
__FLTAR_ADDTOLIST($ASROOTFILEMATCHLIST,$SRETPATH&$SNAME)
ELSE
__FLTAR_ADDTOLIST($ASFILEMATCHLIST,$SRETPATH&$SNAME)
ENDIF
ENDIF
ENDIF
ELSE
IF $FFOLDER THEN
IF $IRETURN<>1 AND STRINGREGEXP($SNAME,$SINCLUDE_FOLDER_MASK)AND NOT STRINGREGEXP($SNAME,$SEXCLUDE_FOLDER_MASK)THEN
__FLTAR_ADDTOLIST($ASRETURNLIST,$SRETPATH&$SNAME&$SFOLDERSLASH)
ENDIF
ELSE
IF $IRETURN<>2 AND STRINGREGEXP($SNAME,$SINCLUDE_FILE_MASK)AND NOT STRINGREGEXP($SNAME,$SEXCLUDE_FILE_MASK)THEN
__FLTAR_ADDTOLIST($ASRETURNLIST,$SRETPATH&$SNAME)
ENDIF
ENDIF
ENDIF
WEND
FILECLOSE($HSEARCH)
WEND
IF $IHIDE_HS THEN
DLLCLOSE($HDLL)
ENDIF
IF $ISORT THEN
SWITCH $IRETURN
CASE 2
IF $ASFOLDERMATCHLIST[0]=0 THEN RETURN SETERROR(1,9,"")
REDIM $ASFOLDERMATCHLIST[$ASFOLDERMATCHLIST[0]+1]
$ASRETURNLIST=$ASFOLDERMATCHLIST
__ARRAYDUALPIVOTSORT($ASRETURNLIST,1,$ASRETURNLIST[0])
CASE 1
IF $ASROOTFILEMATCHLIST[0]=0 AND $ASFILEMATCHLIST[0]=0 THEN RETURN SETERROR(1,9,"")
IF $IRETURNPATH=0 THEN
__FLTAR_ADDFILELISTS($ASRETURNLIST,$ASROOTFILEMATCHLIST,$ASFILEMATCHLIST)
__ARRAYDUALPIVOTSORT($ASRETURNLIST,1,$ASRETURNLIST[0])
ELSE
__FLTAR_ADDFILELISTS($ASRETURNLIST,$ASROOTFILEMATCHLIST,$ASFILEMATCHLIST,1)
ENDIF
CASE 0
IF $ASROOTFILEMATCHLIST[0]=0 AND $ASFOLDERMATCHLIST[0]=0 THEN RETURN SETERROR(1,9,"")
IF $IRETURNPATH=0 THEN
__FLTAR_ADDFILELISTS($ASRETURNLIST,$ASROOTFILEMATCHLIST,$ASFILEMATCHLIST)
$ASRETURNLIST[0]+=$ASFOLDERMATCHLIST[0]
REDIM $ASFOLDERMATCHLIST[$ASFOLDERMATCHLIST[0]+1]
_ARRAYCONCATENATE($ASRETURNLIST,$ASFOLDERMATCHLIST)
__ARRAYDUALPIVOTSORT($ASRETURNLIST,1,$ASRETURNLIST[0])
ELSE
LOCAL $ASRETURNLIST[$ASFILEMATCHLIST[0]+$ASROOTFILEMATCHLIST[0]+$ASFOLDERMATCHLIST[0]+1]
$ASRETURNLIST[0]=$ASFILEMATCHLIST[0]+$ASROOTFILEMATCHLIST[0]+$ASFOLDERMATCHLIST[0]
__ARRAYDUALPIVOTSORT($ASROOTFILEMATCHLIST,1,$ASROOTFILEMATCHLIST[0])
FOR $I=1 TO $ASROOTFILEMATCHLIST[0]
$ASRETURNLIST[$I]=$ASROOTFILEMATCHLIST[$I]
NEXT
LOCAL $INEXTINSERTIONINDEX=$ASROOTFILEMATCHLIST[0]+1
__ARRAYDUALPIVOTSORT($ASFOLDERMATCHLIST,1,$ASFOLDERMATCHLIST[0])
FOR $I=1 TO $ASFOLDERMATCHLIST[0]
$ASRETURNLIST[$INEXTINSERTIONINDEX]=$ASFOLDERMATCHLIST[$I]
$INEXTINSERTIONINDEX+=1
IF $SFOLDERSLASH THEN
$SFOLDERTOFIND=$ASFOLDERMATCHLIST[$I]
ELSE
$SFOLDERTOFIND=$ASFOLDERMATCHLIST[$I]&"\"
ENDIF
FOR $J=1 TO $ASFOLDERFILESECTIONLIST[0][0]
IF $SFOLDERTOFIND=$ASFOLDERFILESECTIONLIST[$J][0]THEN
$IFILESECTIONSTARTINDEX=$ASFOLDERFILESECTIONLIST[$J][1]
IF $J=$ASFOLDERFILESECTIONLIST[0][0]THEN
$IFILESECTIONENDINDEX=$ASFILEMATCHLIST[0]
ELSE
$IFILESECTIONENDINDEX=$ASFOLDERFILESECTIONLIST[$J+1][1]-1
ENDIF
IF $ISORT=1 THEN
__ARRAYDUALPIVOTSORT($ASFILEMATCHLIST,$IFILESECTIONSTARTINDEX,$IFILESECTIONENDINDEX)
ENDIF
FOR $K=$IFILESECTIONSTARTINDEX TO $IFILESECTIONENDINDEX
$ASRETURNLIST[$INEXTINSERTIONINDEX]=$ASFILEMATCHLIST[$K]
$INEXTINSERTIONINDEX+=1
NEXT
EXITLOOP
ENDIF
NEXT
NEXT
ENDIF
ENDSWITCH
ELSE
IF $ASRETURNLIST[0]=0 THEN RETURN SETERROR(1,9,"")
REDIM $ASRETURNLIST[$ASRETURNLIST[0]+1]
ENDIF
RETURN $ASRETURNLIST
ENDFUNC
FUNC __FLTAR_ADDFILELISTS(BYREF $ASTARGET,$ASSOURCE_1,$ASSOURCE_2,$ISORT=0)
REDIM $ASSOURCE_1[$ASSOURCE_1[0]+1]
IF $ISORT=1 THEN __ARRAYDUALPIVOTSORT($ASSOURCE_1,1,$ASSOURCE_1[0])
$ASTARGET=$ASSOURCE_1
$ASTARGET[0]+=$ASSOURCE_2[0]
REDIM $ASSOURCE_2[$ASSOURCE_2[0]+1]
IF $ISORT=1 THEN __ARRAYDUALPIVOTSORT($ASSOURCE_2,1,$ASSOURCE_2[0])
_ARRAYCONCATENATE($ASTARGET,$ASSOURCE_2)
ENDFUNC
FUNC __FLTAR_ADDTOLIST(BYREF $ALIST,$VVALUE_0,$VVALUE_1=-1)
IF $VVALUE_1=-1 THEN
$ALIST[0]+=1
IF UBOUND($ALIST)<=$ALIST[0]THEN REDIM $ALIST[UBOUND($ALIST)*2]
$ALIST[$ALIST[0]]=$VVALUE_0
ELSE
$ALIST[0][0]+=1
IF UBOUND($ALIST)<=$ALIST[0][0]THEN REDIM $ALIST[UBOUND($ALIST)*2][2]
$ALIST[$ALIST[0][0]][0]=$VVALUE_0
$ALIST[$ALIST[0][0]][1]=$VVALUE_1
ENDIF
ENDFUNC
FUNC __FLTAR_LISTTOMASK(BYREF $SMASK,$SLIST)
IF STRINGREGEXP($SLIST,"\\|/|:|\<|\>|\|")THEN RETURN 0
$SLIST=STRINGREPLACE(STRINGSTRIPWS(STRINGREGEXPREPLACE($SLIST,"\s*;\s*",";"),3),";","|")
$SLIST=STRINGREPLACE(STRINGREPLACE(STRINGREGEXPREPLACE($SLIST,"[][$^.{}()+\-]","\\$0"),"?","."),"*",".*?")
$SMASK="(?i)^("&$SLIST&")\z"
RETURN 1
ENDFUNC
FUNC _FILEPRINT($SFILEPATH,$ISHOW=@SW_HIDE)
IF $ISHOW=DEFAULT THEN $ISHOW=@SW_HIDE
RETURN SHELLEXECUTE($SFILEPATH,"",@WORKINGDIR,"print",$ISHOW)
ENDFUNC
FUNC _FILEREADTOARRAY($SFILEPATH,BYREF $AARRAY,$IFLAG=1)
IF $IFLAG OR $IFLAG=DEFAULT THEN
LOCAL $HFILEOPEN=FILEOPEN($SFILEPATH,$FO_READ)
IF $HFILEOPEN=-1 THEN RETURN SETERROR(1,0,0)
LOCAL $SFILEREAD=FILEREAD($HFILEOPEN)
FILECLOSE($HFILEOPEN)
IF STRINGLEN($SFILEREAD)THEN
$AARRAY=STRINGREGEXP(@CRLF&$SFILEREAD,"([^\r\n]*)(?:\r\n|\n|\r|$)",3)
$AARRAY[0]=UBOUND($AARRAY)-2
REDIM $AARRAY[UBOUND($AARRAY)-1]
ELSE
RETURN SETERROR(2,0,0)
ENDIF
ELSE
$AARRAY=FILEREADTOARRAY($SFILEPATH)
IF @ERROR THEN RETURN SETERROR(@ERROR,0,0)
ENDIF
RETURN 1
ENDFUNC
FUNC _FILEWRITEFROMARRAY($SFILEPATH,CONST BYREF $AARRAY,$IBASE=DEFAULT ,$IUBOUND=DEFAULT ,$SDELIMETER="|")
IF NOT ISARRAY($AARRAY)THEN RETURN SETERROR(2,0,0)
LOCAL $IDIMS=UBOUND($AARRAY,0)
IF $IDIMS>2 THEN RETURN SETERROR(4,0,0)
LOCAL $ILAST=UBOUND($AARRAY)-1
IF $IUBOUND=DEFAULT OR $IUBOUND>$ILAST THEN $IUBOUND=$ILAST
IF $IBASE<0 OR $IBASE=DEFAULT THEN $IBASE=0
IF $IBASE>$IUBOUND THEN RETURN SETERROR(5,0,0)
IF $SDELIMETER=DEFAULT THEN $SDELIMETER="|"
LOCAL $HFILEOPEN=$SFILEPATH
IF ISSTRING($SFILEPATH)THEN
$HFILEOPEN=FILEOPEN($SFILEPATH,$FO_OVERWRITE)
ENDIF
IF $HFILEOPEN=-1 THEN RETURN SETERROR(1,0,0)
LOCAL $IERROR=0
SWITCH $IDIMS
CASE 1
FOR $I=$IBASE TO $IUBOUND
IF FILEWRITE($HFILEOPEN,$AARRAY[$I]&@CRLF)=0 THEN
$IERROR=3
EXITLOOP
ENDIF
NEXT
CASE 2
LOCAL $STEMP
LOCAL $ICOLS=UBOUND($AARRAY,2)
FOR $I=$IBASE TO $IUBOUND
$STEMP=$AARRAY[$I][0]
FOR $J=1 TO $ICOLS-1
$STEMP&=$SDELIMETER&$AARRAY[$I][$J]
NEXT
IF FILEWRITE($HFILEOPEN,$STEMP&@CRLF)=0 THEN
$IERROR=3
EXITLOOP
ENDIF
NEXT
ENDSWITCH
IF ISSTRING($SFILEPATH)THEN FILECLOSE($HFILEOPEN)
IF $IERROR THEN RETURN SETERROR($IERROR,0,0)
RETURN 1
ENDFUNC
FUNC _FILEWRITELOG($SLOGPATH,$SLOGMSG,$IFLAG=-1)
LOCAL $IOPENMODE=$FO_APPEND
LOCAL $SDATENOW=@YEAR&"-"&@MON&"-"&@MDAY
LOCAL $STIMENOW=@HOUR&":"&@MIN&":"&@SEC
LOCAL $SMSG=$SDATENOW&" "&$STIMENOW&" : "&$SLOGMSG
IF $IFLAG=DEFAULT THEN $IFLAG=-1
IF $IFLAG<>-1 THEN
$IOPENMODE=$FO_OVERWRITE
$SMSG&=@CRLF&FILEREAD($SLOGPATH)
ENDIF
LOCAL $HFILEOPEN=$SLOGPATH
IF ISSTRING($SLOGPATH)THEN
$HFILEOPEN=FILEOPEN($SLOGPATH,$IOPENMODE)
ENDIF
IF $HFILEOPEN=-1 THEN RETURN SETERROR(1,0,0)
LOCAL $IRETURN=FILEWRITELINE($HFILEOPEN,$SMSG)
IF ISSTRING($SLOGPATH)THEN $IRETURN=FILECLOSE($HFILEOPEN)
IF $IRETURN<=0 THEN RETURN SETERROR(2,$IRETURN,0)
RETURN $IRETURN
ENDFUNC
FUNC _FILEWRITETOLINE($SFILEPATH,$ILINE,$STEXT,$IOVERWRITE=0)
IF $ILINE<=0 THEN RETURN SETERROR(4,0,0)
IF NOT ISSTRING($STEXT)THEN
$STEXT=STRING($STEXT)
IF $STEXT="" THEN RETURN SETERROR(6,0,0)
ENDIF
IF $IOVERWRITE<>0 AND $IOVERWRITE<>1 THEN RETURN SETERROR(5,0,0)
IF FILEEXISTS($SFILEPATH)=0 THEN RETURN SETERROR(2,0,0)
LOCAL $SFILEREAD=FILEREAD($SFILEPATH)
LOCAL $AARRAY=STRINGREGEXP(@CRLF&$SFILEREAD&@CRLF,"([^\r\n]*)(?:\r\n|\n|\r)(?:[\r\n]$)?",3)
$AARRAY[0]=UBOUND($AARRAY)-1
IF ($AARRAY[0]+1)<$ILINE THEN RETURN SETERROR(1,0,0)
LOCAL $HFILEOPEN=FILEOPEN($SFILEPATH,FILEGETENCODING($SFILEPATH)+$FO_OVERWRITE)
IF $HFILEOPEN=-1 THEN RETURN SETERROR(3,0,0)
$SFILEREAD=""
FOR $I=1 TO $AARRAY[0]
IF $I=$ILINE THEN
IF $IOVERWRITE THEN
IF $STEXT<>"" THEN $SFILEREAD&=$STEXT&@CRLF
ELSE
$SFILEREAD&=$STEXT&@CRLF&$AARRAY[$I]&@CRLF
ENDIF
ELSEIF $I<$AARRAY[0]THEN
$SFILEREAD&=$AARRAY[$I]&@CRLF
ELSEIF $I=$AARRAY[0]THEN
$SFILEREAD&=$AARRAY[$I]
ENDIF
NEXT
FILEWRITE($HFILEOPEN,$SFILEREAD)
FILECLOSE($HFILEOPEN)
RETURN 1
ENDFUNC
FUNC _PATHFULL($SRELATIVEPATH,$SBASEPATH=@WORKINGDIR)
IF NOT $SRELATIVEPATH OR $SRELATIVEPATH="." THEN RETURN $SBASEPATH
LOCAL $SFULLPATH=STRINGREPLACE($SRELATIVEPATH,"/","\")
LOCAL CONST $SFULLPATHCONST=$SFULLPATH
LOCAL $SPATH
LOCAL $BROOTONLY=STRINGLEFT($SFULLPATH,1)="\" AND STRINGMID($SFULLPATH,2,1)<>"\"
IF $SBASEPATH=DEFAULT THEN $SBASEPATH=@WORKINGDIR
FOR $I=1 TO 2
$SPATH=STRINGLEFT($SFULLPATH,2)
IF $SPATH="\\" THEN
$SFULLPATH=STRINGTRIMLEFT($SFULLPATH,2)
LOCAL $NSERVERLEN=STRINGINSTR($SFULLPATH,"\")-1
$SPATH="\\"&STRINGLEFT($SFULLPATH,$NSERVERLEN)
$SFULLPATH=STRINGTRIMLEFT($SFULLPATH,$NSERVERLEN)
EXITLOOP
ELSEIF STRINGRIGHT($SPATH,1)=":" THEN
$SFULLPATH=STRINGTRIMLEFT($SFULLPATH,2)
EXITLOOP
ELSE
$SFULLPATH=$SBASEPATH&"\"&$SFULLPATH
ENDIF
NEXT
IF STRINGLEFT($SFULLPATH,1)<>"\" THEN
IF STRINGLEFT($SFULLPATHCONST,2)=STRINGLEFT($SBASEPATH,2)THEN
$SFULLPATH=$SBASEPATH&"\"&$SFULLPATH
ELSE
$SFULLPATH="\"&$SFULLPATH
ENDIF
ENDIF
LOCAL $ATEMP=STRINGSPLIT($SFULLPATH,"\")
LOCAL $APATHPARTS[$ATEMP[0]],$J=0
FOR $I=2 TO $ATEMP[0]
IF $ATEMP[$I]=".." THEN
IF $J THEN $J-=1
ELSEIF NOT ($ATEMP[$I]="" AND $I<>$ATEMP[0])AND $ATEMP[$I]<>"." THEN
$APATHPARTS[$J]=$ATEMP[$I]
$J+=1
ENDIF
NEXT
$SFULLPATH=$SPATH
IF NOT $BROOTONLY THEN
FOR $I=0 TO $J-1
$SFULLPATH&="\"&$APATHPARTS[$I]
NEXT
ELSE
$SFULLPATH&=$SFULLPATHCONST
IF STRINGINSTR($SFULLPATH,"..")THEN $SFULLPATH=_PATHFULL($SFULLPATH)
ENDIF
DO
$SFULLPATH=STRINGREPLACE($SFULLPATH,".\","\")
UNTIL @EXTENDED=0
RETURN $SFULLPATH
ENDFUNC
FUNC _PATHGETRELATIVE($SFROM,$STO)
IF STRINGRIGHT($SFROM,1)<>"\" THEN $SFROM&="\"
IF STRINGRIGHT($STO,1)<>"\" THEN $STO&="\"
IF $SFROM=$STO THEN RETURN SETERROR(1,0,STRINGTRIMRIGHT($STO,1))
LOCAL $ASFROM=STRINGSPLIT($SFROM,"\")
LOCAL $ASTO=STRINGSPLIT($STO,"\")
IF $ASFROM[1]<>$ASTO[1]THEN RETURN SETERROR(2,0,STRINGTRIMRIGHT($STO,1))
LOCAL $I=2
LOCAL $IDIFF=1
WHILE 1
IF $ASFROM[$I]<>$ASTO[$I]THEN
$IDIFF=$I
EXITLOOP
ENDIF
$I+=1
WEND
$I=1
LOCAL $SRELPATH=""
FOR $J=1 TO $ASTO[0]
IF $I>=$IDIFF THEN
$SRELPATH&="\"&$ASTO[$I]
ENDIF
$I+=1
NEXT
$SRELPATH=STRINGTRIMLEFT($SRELPATH,1)
$I=1
FOR $J=1 TO $ASFROM[0]
IF $I>$IDIFF THEN
$SRELPATH="..\"&$SRELPATH
ENDIF
$I+=1
NEXT
IF STRINGRIGHT($SRELPATH,1)=="\" THEN $SRELPATH=STRINGTRIMRIGHT($SRELPATH,1)
RETURN $SRELPATH
ENDFUNC
FUNC _PATHMAKE($SDRIVE,$SDIR,$SFILENAME,$SEXTENSION)
IF STRINGLEN($SDRIVE)THEN
IF NOT (STRINGLEFT($SDRIVE,2)="\\")THEN $SDRIVE=STRINGLEFT($SDRIVE,1)&":"
ENDIF
IF STRINGLEN($SDIR)THEN
IF NOT (STRINGRIGHT($SDIR,1)="\")AND NOT (STRINGRIGHT($SDIR,1)="/")THEN $SDIR=$SDIR&"\"
ENDIF
IF STRINGLEN($SDIR)THEN
IF NOT (STRINGLEFT($SDIR,1)="\")AND NOT (STRINGLEFT($SDIR,1)="/")THEN $SDIR="\"&$SDIR
ENDIF
IF STRINGLEN($SEXTENSION)THEN
IF NOT (STRINGLEFT($SEXTENSION,1)=".")THEN $SEXTENSION="."&$SEXTENSION
ENDIF
RETURN $SDRIVE&$SDIR&$SFILENAME&$SEXTENSION
ENDFUNC
FUNC _PATHSPLIT($SFILEPATH,BYREF $SDRIVE,BYREF $SDIR,BYREF $SFILENAME,BYREF $SEXTENSION)
LOCAL $AARRAY=STRINGREGEXP($SFILEPATH,"^\h*((?:\\\\\?\\)*(\\\\[^\?\/\\]+|[A-Za-z]:)?(.*[\/\\]\h*)?((?:[^\.\/\\]|(?(?=\.[^\/\\]*\.)\.))*)?([^\/\\]*))$",1)
IF @ERROR THEN
REDIM $AARRAY[5]
$AARRAY[0]=$SFILEPATH
ENDIF
$SDRIVE=$AARRAY[1]
IF STRINGLEFT($AARRAY[2],1)=="/" THEN
$SDIR=STRINGREGEXPREPLACE($AARRAY[2],"\h*[\/\\]+\h*","\/")
ELSE
$SDIR=STRINGREGEXPREPLACE($AARRAY[2],"\h*[\/\\]+\h*","\\")
ENDIF
$SFILENAME=$AARRAY[3]
$SEXTENSION=$AARRAY[4]
RETURN $AARRAY
ENDFUNC
FUNC _REPLACESTRINGINFILE($SFILEPATH,$SSEARCHSTRING,$SREPLACESTRING,$ICASESENSITIVE=0,$IOCCURANCE=1)
IF STRINGINSTR(FILEGETATTRIB($SFILEPATH),"R")THEN RETURN SETERROR(1,0,-1)
LOCAL $HFILEOPEN=FILEOPEN($SFILEPATH,$FO_READ)
IF $HFILEOPEN=-1 THEN RETURN SETERROR(2,0,-1)
LOCAL $SFILEREAD=FILEREAD($HFILEOPEN)
FILECLOSE($HFILEOPEN)
IF $ICASESENSITIVE=DEFAULT THEN $ICASESENSITIVE=0
IF $IOCCURANCE=DEFAULT THEN $IOCCURANCE=1
$SFILEREAD=STRINGREPLACE($SFILEREAD,$SSEARCHSTRING,$SREPLACESTRING,1-$IOCCURANCE,$ICASESENSITIVE)
LOCAL $IRETURN=@EXTENDED
IF $IRETURN THEN
LOCAL $IFILEENCODING=FILEGETENCODING($SFILEPATH)
$HFILEOPEN=FILEOPEN($SFILEPATH,$IFILEENCODING+$FO_OVERWRITE)
IF $HFILEOPEN=-1 THEN RETURN SETERROR(3,0,-1)
FILEWRITE($HFILEOPEN,$SFILEREAD)
FILECLOSE($HFILEOPEN)
ENDIF
RETURN $IRETURN
ENDFUNC
FUNC _TEMPFILE($SDIRECTORYNAME=@TEMPDIR,$SFILEPREFIX="~",$SFILEEXTENSION=".tmp",$IRANDOMLENGTH=7)
IF $IRANDOMLENGTH=DEFAULT OR $IRANDOMLENGTH<=0 THEN $IRANDOMLENGTH=7
IF $SDIRECTORYNAME=DEFAULT OR (NOT FILEEXISTS($SDIRECTORYNAME))THEN $SDIRECTORYNAME=@TEMPDIR
IF $SFILEEXTENSION=DEFAULT THEN $SFILEEXTENSION=".tmp"
IF $SFILEPREFIX=DEFAULT THEN $SFILEPREFIX="~"
IF NOT FILEEXISTS($SDIRECTORYNAME)THEN $SDIRECTORYNAME=@SCRIPTDIR
$SDIRECTORYNAME=STRINGREGEXPREPLACE($SDIRECTORYNAME,"[\\/]+$","")
$SFILEEXTENSION=STRINGREGEXPREPLACE($SFILEEXTENSION,"^\.+","")
$SFILEPREFIX=STRINGREGEXPREPLACE($SFILEPREFIX,'[\\/:*?"<>|]',"")
LOCAL $STEMPNAME=""
DO
$STEMPNAME=""
WHILE STRINGLEN($STEMPNAME)<$IRANDOMLENGTH
$STEMPNAME&=CHR(RANDOM(97,122,1))
WEND
$STEMPNAME=$SDIRECTORYNAME&"\"&$SFILEPREFIX&$STEMPNAME&"."&$SFILEEXTENSION
UNTIL NOT FILEEXISTS($STEMPNAME)
RETURN $STEMPNAME
ENDFUNC
#RequireAdmin
OPT("SendKeyDownDelay",20)
GLOBAL CONST $GUI_CHECKED=1
GLOBAL CONST $GUI_UNCHECKED=4
GLOBAL CONST $GUI_SHOW=16
GLOBAL CONST $GUI_HIDE=32
;HOTKEYSET("{F11}","START")
;HOTKEYSET("{F10}","QUIT")
;HOTKEYSET("{F9}","MODE")
;HOTKEYSET("{F6}","SPACE")
OPT("SendCapslockMode",0)
OPT("RunErrorsFatal",1)
GLOBAL CONST $GUI_DISABLE=128
GLOBAL CONST $GUI_ENABLE=64
GLOBAL CONST $GUI_EVENT_CLOSE=-3
GLOBAL CONST $GUI_GR_RECT=10
GLOBAL CONST $GUI_GR_COLOR=8
GLOBAL CONST $GUI_GR_PENSIZE=24
GLOBAL CONST $GUI_GR_MOVE=6
GLOBAL CONST $GUI_GR_LINE=2
GLOBAL CONST $GUI_GR_PIE=14
GLOBAL CONST $WS_VSCROLL=2097152
GLOBAL CONST $ES_LEFT=0
GLOBAL CONST $ES_CENTER=1
GLOBAL CONST $ES_RIGHT=2
GLOBAL CONST $ES_MULTILINE=4
GLOBAL CONST $ES_UPPERCASE=8
GLOBAL CONST $ES_LOWERCASE=16
GLOBAL CONST $ES_PASSWORD=32
GLOBAL CONST $ES_AUTOVSCROLL=64
GLOBAL CONST $ES_AUTOHSCROLL=128
GLOBAL CONST $ES_NOHIDESEL=256
GLOBAL CONST $ES_OEMCONVERT=1024
GLOBAL CONST $ES_READONLY=2048
GLOBAL CONST $ES_WANTRETURN=4096
GLOBAL CONST $ES_NUMBER=8192
GLOBAL CONST $GUI_SS_DEFAULT_INPUT=BITOR($ES_LEFT,$ES_AUTOHSCROLL)
;=======================SHREK INCLUDE=============================
#cs
;#include <imageSearchEX.au3>
#include <_ImageSearch_UDF.au3>
#include <_ImageSearch_Tool.au3>
#include <SendMessage.au3>
#include <WinAPISys.au3>
#include <WinAPIvkeysConstants.au3>
#include <WinAPIError.au3>
#include <Timers.au3>
#include <StaticConstants.au3>
#include <ColorConstants.au3>
#include <EditConstants.au3>
;#include <Timers.au3>
#Include <StructureConstants.au3>
#Include <Date.au3>
#include <WindowsConstants.au3>
;#include <WindowsConstants.au3>
;#include <GUIConstantsEx.au3>
#include <Misc.au3>
;#include <MsgBoxConstants.au3>
Opt("MouseCoordMode", 0)
;Opt("SendKeyDownDelay", 50)
Opt("SendKeyDelay", 200)
#Region Tạm thời vô hiệu hóa để Test autoTrainning
HotKeySet("{F2}","F6War")
HotKeySet("{F3}","F7War")
HotKeySet("{F4}","F8War")
HotKeySet("{F6}","_GameGetMouse")
HotKeySet("{F7}","_Training");_Refinement
HotKeySet("{F8}","_Refinement")
#EndRegion
HotKeySet("{F1}","__Exit")
#ce
#Region Khu vực khai báo biến để chạy AutoIt
   Global $Hwnd_9D
   Global $IsPause=0
   Global $_Mod_train=0
   Global $F7Auto, $F6Enable, $F8Auto, $F7Enable, $F9Auto, $F8Enable, $Interrupt, $_CheckMove=0
   Global $_OldX, $_OldY, $_mMouseX, $_mMouseY = 35
   Global $_XClient, $_YClient = 35
   Global $_ClientPos
   Global $buttontext = "Start"
   Global $DCuaso9D;= ControlGetHandle("[Class:X3DKernel]","","")
   Global $_GuiX, $_GuiY, $_HeightClient, $_WidthClient
   Global $_Time_Reset = False
   Global $hTimeoutTimer = TimerInit()
   Global $_Year, $_Month, $_Date, $_Trial_Mode
   Dim $hCursor, $hOldCursor = 0
   Dim $_hCursor=0
   Dim $_hNewCursor=0
   Dim $_Time_Interval, $_RefPause =0
   Dim $hStarttime, $_RefMaxLvl
   Dim $_Turn_Skill=1
#EndRegion
#Region Khu vực khai báo biến cho ImageSearch
   $imgdir=@ScriptDir&"\"
   Global $_Mod_mob = $imgdir & "Mob.bmp"
   ;Local $_Mod_mob_Return=_ImageSearch($_Mod_mob)
   Global $_Mod_combat = $imgdir & "combatmod.bmp"
   ;Local $_Mod_combat_Return=_ImageSearch($_Mod_mob)
   Global $_Mod_peacemod = $imgdir & "peacemod.bmp"
   ;Local $_Mod_peacemod_Return=_ImageSearch($_Mod_mob)
   Global $_Select_Bag=$imgdir&"Bag_1.bmp"
   ;Local $_Select_Bag_Return=_ImageSearch($_Select_Bag)
   Global $_Select_Resource=$imgdir&"resource.bmp"
   ;Local $_Select_Resource_Return=_ImageSearch($_Select_Resource)
   Global $_Select_Guardian=$imgdir&"chonpet1.bmp"
   Global $_Select_Guardian_Return=_ImageSearch($_Select_Guardian);guardian1
   Global $_Select_Guardian1=$imgdir&"chonpet2.bmp"
   Global $_Select_Guardian1_Return=_ImageSearch($_Select_Guardian1)
   Global $_Select_Energy=$imgdir&"energy1.bmp"
   Global $_Select_Energy_Return=_ImageSearch($_Select_Energy)
   Global $_Select_Revive_1=$imgdir&"hoisinhhd.bmp"
   Global $_Select_Revive_2=$imgdir&"hoada_2.bmp"
   Global $_Select_Revive_3=$imgdir&"monphai_1.bmp"
   Global $_Select_Revive_4=$imgdir&"taicho_1.bmp"
   Global $_Select_Revive_1Return=_ImageSearch($_Select_Revive_1)
   Global $_Select_Revive_2Return=_ImageSearch($_Select_Revive_2)
   Global $_Select_Revive_3Return=_ImageSearch($_Select_Revive_3)
   Global $_Select_Revive_4Return=_ImageSearch($_Select_Revive_4)
   Global $_Select_Mau=$imgdir&"mau.bmp"
   Global $_Select_Mau_Return=_ImageSearch($_Select_Mau)
   Global $Select_PetCharge=$imgdir&"recharge.bmp"
   Global $_Select_Rechage_Return=_ImageSearch($Select_PetCharge)
   Global $Select_PetCharge1=$imgdir&"recharge_1.bmp"
   Global $_Select_Rechage1_Return
   Global $_Select_Yes=$imgdir&"ok3.bmp"
   Global $_Select_Yes_Return=_ImageSearch($_Select_Yes)
   Global $_Select_Yes1=$imgdir&"ok2.bmp"
   Global $_Select_Yes1_Return=_ImageSearch($_Select_Yes1)
   Global $_Select_Petlist=$imgdir&"petlist.bmp"
   Global $_Select_Petlist_Return=_ImageSearch($_Select_Petlist)
   Global $_Select_Summon=$imgdir&"summon.bmp"
   Global $_Select_Summon_Return=_ImageSearch($_Select_Summon)
   Global $_Select_Zombie = $imgdir&"zombie.bmp"
   Global $_Select_Zombie_Return
   Global $_Select_AutoLoot = $imgdir&"autoloot.bmp"
   Global $_Select_AutoLoot_Return
   Global $_Select_LootSetup = $imgdir&"autoloot1.bmp"
   Global $_Select_LootSetup_Return
   Global $_Select_Energy_Selected = $imgdir&"energy_selected.bmp"
   Global $_Select_Energy_Selected_Return
   Global $_PetStarttime
   Global $_Select_Disconnect = $imgdir&"disconnect.bmp"
   Global $_Select_Disconnect_1 = $imgdir&"disconnect_1.bmp"
   Global $_Select_Disconnect_2 = $imgdir&"disconnect_2.bmp"
   Global $_Select_Disconnect_3 = $imgdir&"disconnect_3.bmp"
   Global $_Select_Disconnect_4 = $imgdir&"disconnect_4.bmp"
   Global $_Select_Disconnect_5 = $imgdir&"disconnect_4.bmp"
   Global $_Select_Disconnect_Return, $_Select_Disconnect_1_Return, $_Select_Disconnect_2_Return, $_Select_Disconnect_3_Return, $_Select_Disconnect_4_Return, $_Select_Disconnect_5_Return
   Global $_Select_Login_1 = $imgdir&"login_1.bmp"
   Global $_Select_Login_2 = $imgdir&"login_2.bmp"
   Global $_Select_Login_3 = $imgdir&"login_3.bmp"
   Global $_Select_Login_4 = $imgdir&"login_4.bmp"
   Global $_Select_Login_5 = $imgdir&"login_5.bmp"
   Global $_Select_Login_6 = $imgdir&"login_6.bmp"
   Global $_Select_Login_1_Return, $_Select_Login_2_Return, $_Select_Login_3_Return, $_Select_Login_4_Return, $_Select_Login_5_Return, $_Select_Login_6_Return
   Global $_Select_Pass2_Input = $imgdir&"pass2_input.bmp"
   Global $_Select_Pass2_Input1 = $imgdir&"pass2_input_1.bmp"
   Global $_Select_Pass2_Input_Return, $_Select_Pass2_Input_Return1

;======================END SHREK INCLUDE==========================
#Region variable
GLOBAL $I
GLOBAL $HWND=WINGETHANDLE("[CLASS:X3DKernel]","")
GLOBAL $MODE=1
GLOBAL $TAB="{TAB}"
GLOBAL $ENTER="{ENTER}"
#EndRegion variable
#Region ### START Koda GUI section ###
$FORM=GUICREATE("MouseDrv",450,555)
GUICtrlCreateTab(0,10,450,555)
$_Auto_MouseDrv_Tab = GUICtrlCreateTabItem("_MouseDrv")
$LABELGUIDE=GUICTRLCREATELABEL("F11: Run/Pause"&@CRLF&"F10: (3 times) Exit"&@CRLF&"F9: Change Mode"&@CRLF&"F6: On/Off Space",280,10)
GUICTRLSETCOLOR(-1,16711680)
#Region Skill UI & Variable
LOCAL $GR_SKILL_POSX=6
LOCAL $GR_SKILL_POSY=0
GLOBAL $TIMESTARTSKILL=0
GLOBAL $TIMEDIFFSKILL
GLOBAL $ACTIVSKILL[15]
GLOBAL $SKILL[15]
GLOBAL $CASTINGSKILL[15]
GLOBAL $COOLDOWNSKILL[15]
GLOBAL $DELAYSKILL[15]
GLOBAL $DELAYSORTED[5][11]
GLOBAL $TIMERSKILL[15]
GLOBAL $TIMEDIFFSKILL[15]
$SKILL[1]="1"
$SKILL[2]="2"
$SKILL[3]="3"
$SKILL[4]="4"
$SKILL[5]="5"
$SKILL[6]="6"
$SKILL[7]="7"
$SKILL[8]="8"
$SKILL[9]="9"
$SKILL[10]="0"
$SKILL[11]="p"
$SKILL[12]="{SPACE}"
$SKILL[13]="a"
$SKILL[14]=""
GUICTRLCREATEGROUP("",$GR_SKILL_POSX,$GR_SKILL_POSY,260,255)
$LABEL30=GUICTRLCREATELABEL("delay",$GR_SKILL_POSX+35,$GR_SKILL_POSY+10)
$LABEL31=GUICTRLCREATELABEL("casting",$GR_SKILL_POSX+100,$GR_SKILL_POSY+10)
$LABEL32=GUICTRLCREATELABEL("cooldown",$GR_SKILL_POSX+164,$GR_SKILL_POSY+10)
$ACTIVSKILL[1]=GUICTRLCREATECHECKBOX("1",$GR_SKILL_POSX+5,$GR_SKILL_POSY+25)
$DELAYSKILL[1]=GUICTRLCREATEINPUT("",$GR_SKILL_POSX+35,$GR_SKILL_POSY+25,60,21,BITOR($GUI_SS_DEFAULT_INPUT,$ES_RIGHT,$ES_NUMBER))
$CASTINGSKILL[1]=GUICTRLCREATEINPUT("",$GR_SKILL_POSX+100,$GR_SKILL_POSY+25,60,21,BITOR($GUI_SS_DEFAULT_INPUT,$ES_RIGHT,$ES_NUMBER))
$COOLDOWNSKILL[1]=GUICTRLCREATEINPUT("",$GR_SKILL_POSX+164,$GR_SKILL_POSY+25,60,21,BITOR($GUI_SS_DEFAULT_INPUT,$ES_RIGHT,$ES_NUMBER))
$LABELSKILL1A=GUICTRLCREATELABEL("ms",$GR_SKILL_POSX+234,$GR_SKILL_POSY+30)
$ACTIVSKILL[2]=GUICTRLCREATECHECKBOX("2",$GR_SKILL_POSX+5,$GR_SKILL_POSY+45)
$DELAYSKILL[2]=GUICTRLCREATEINPUT("",$GR_SKILL_POSX+35,$GR_SKILL_POSY+45,60,21,BITOR($GUI_SS_DEFAULT_INPUT,$ES_RIGHT,$ES_NUMBER))
$CASTINGSKILL[2]=GUICTRLCREATEINPUT("",$GR_SKILL_POSX+100,$GR_SKILL_POSY+45,60,21,BITOR($GUI_SS_DEFAULT_INPUT,$ES_RIGHT,$ES_NUMBER))
$COOLDOWNSKILL[2]=GUICTRLCREATEINPUT("",$GR_SKILL_POSX+164,$GR_SKILL_POSY+45,60,21,BITOR($GUI_SS_DEFAULT_INPUT,$ES_RIGHT,$ES_NUMBER))
$LABELSKILL2A=GUICTRLCREATELABEL("ms",$GR_SKILL_POSX+234,$GR_SKILL_POSY+50)
$ACTIVSKILL[3]=GUICTRLCREATECHECKBOX("3",$GR_SKILL_POSX+5,$GR_SKILL_POSY+65)
$DELAYSKILL[3]=GUICTRLCREATEINPUT("",$GR_SKILL_POSX+35,$GR_SKILL_POSY+65,60,21,BITOR($GUI_SS_DEFAULT_INPUT,$ES_RIGHT,$ES_NUMBER))
$CASTINGSKILL[3]=GUICTRLCREATEINPUT("",$GR_SKILL_POSX+100,$GR_SKILL_POSY+65,60,21,BITOR($GUI_SS_DEFAULT_INPUT,$ES_RIGHT,$ES_NUMBER))
$COOLDOWNSKILL[3]=GUICTRLCREATEINPUT("",$GR_SKILL_POSX+164,$GR_SKILL_POSY+65,60,21,BITOR($GUI_SS_DEFAULT_INPUT,$ES_RIGHT,$ES_NUMBER))
$LABELSKILL3A=GUICTRLCREATELABEL("ms",$GR_SKILL_POSX+234,$GR_SKILL_POSY+70)
$ACTIVSKILL[4]=GUICTRLCREATECHECKBOX("4",$GR_SKILL_POSX+5,$GR_SKILL_POSY+85)
$DELAYSKILL[4]=GUICTRLCREATEINPUT("",$GR_SKILL_POSX+35,$GR_SKILL_POSY+85,60,21,BITOR($GUI_SS_DEFAULT_INPUT,$ES_RIGHT,$ES_NUMBER))
$CASTINGSKILL[4]=GUICTRLCREATEINPUT("",$GR_SKILL_POSX+100,$GR_SKILL_POSY+85,60,21,BITOR($GUI_SS_DEFAULT_INPUT,$ES_RIGHT,$ES_NUMBER))
$COOLDOWNSKILL[4]=GUICTRLCREATEINPUT("",$GR_SKILL_POSX+164,$GR_SKILL_POSY+85,60,21,BITOR($GUI_SS_DEFAULT_INPUT,$ES_RIGHT,$ES_NUMBER))
$LABELSKILL4A=GUICTRLCREATELABEL("ms",$GR_SKILL_POSX+234,$GR_SKILL_POSY+90)
$ACTIVSKILL[5]=GUICTRLCREATECHECKBOX("5",$GR_SKILL_POSX+5,$GR_SKILL_POSY+105)
$DELAYSKILL[5]=GUICTRLCREATEINPUT("",$GR_SKILL_POSX+35,$GR_SKILL_POSY+105,60,21,BITOR($GUI_SS_DEFAULT_INPUT,$ES_RIGHT,$ES_NUMBER))
$CASTINGSKILL[5]=GUICTRLCREATEINPUT("",$GR_SKILL_POSX+100,$GR_SKILL_POSY+105,60,21,BITOR($GUI_SS_DEFAULT_INPUT,$ES_RIGHT,$ES_NUMBER))
$COOLDOWNSKILL[5]=GUICTRLCREATEINPUT("",$GR_SKILL_POSX+164,$GR_SKILL_POSY+105,60,21,BITOR($GUI_SS_DEFAULT_INPUT,$ES_RIGHT,$ES_NUMBER))
$LABELSKILL5A=GUICTRLCREATELABEL("ms",$GR_SKILL_POSX+234,$GR_SKILL_POSY+110)
$ACTIVSKILL[6]=GUICTRLCREATECHECKBOX("6",$GR_SKILL_POSX+5,$GR_SKILL_POSY+125)
$DELAYSKILL[6]=GUICTRLCREATEINPUT("",$GR_SKILL_POSX+35,$GR_SKILL_POSY+125,60,21,BITOR($GUI_SS_DEFAULT_INPUT,$ES_RIGHT,$ES_NUMBER))
$CASTINGSKILL[6]=GUICTRLCREATEINPUT("",$GR_SKILL_POSX+100,$GR_SKILL_POSY+125,60,21,BITOR($GUI_SS_DEFAULT_INPUT,$ES_RIGHT,$ES_NUMBER))
$COOLDOWNSKILL[6]=GUICTRLCREATEINPUT("",$GR_SKILL_POSX+164,$GR_SKILL_POSY+125,60,21,BITOR($GUI_SS_DEFAULT_INPUT,$ES_RIGHT,$ES_NUMBER))
$LABELSKILL6A=GUICTRLCREATELABEL("ms",$GR_SKILL_POSX+234,$GR_SKILL_POSY+130)
$ACTIVSKILL[7]=GUICTRLCREATECHECKBOX("7",$GR_SKILL_POSX+5,$GR_SKILL_POSY+145)
$DELAYSKILL[7]=GUICTRLCREATEINPUT("",$GR_SKILL_POSX+35,$GR_SKILL_POSY+145,60,21,BITOR($GUI_SS_DEFAULT_INPUT,$ES_RIGHT,$ES_NUMBER))
$CASTINGSKILL[7]=GUICTRLCREATEINPUT("",$GR_SKILL_POSX+100,$GR_SKILL_POSY+145,60,21,BITOR($GUI_SS_DEFAULT_INPUT,$ES_RIGHT,$ES_NUMBER))
$COOLDOWNSKILL[7]=GUICTRLCREATEINPUT("",$GR_SKILL_POSX+164,$GR_SKILL_POSY+145,60,21,BITOR($GUI_SS_DEFAULT_INPUT,$ES_RIGHT,$ES_NUMBER))
$LABELSKILL7A=GUICTRLCREATELABEL("ms",$GR_SKILL_POSX+234,$GR_SKILL_POSY+150)
$ACTIVSKILL[8]=GUICTRLCREATECHECKBOX("8",$GR_SKILL_POSX+5,$GR_SKILL_POSY+165)
$DELAYSKILL[8]=GUICTRLCREATEINPUT("",$GR_SKILL_POSX+35,$GR_SKILL_POSY+165,60,21,BITOR($GUI_SS_DEFAULT_INPUT,$ES_RIGHT,$ES_NUMBER))
$CASTINGSKILL[8]=GUICTRLCREATEINPUT("",$GR_SKILL_POSX+100,$GR_SKILL_POSY+165,60,21,BITOR($GUI_SS_DEFAULT_INPUT,$ES_RIGHT,$ES_NUMBER))
$COOLDOWNSKILL[8]=GUICTRLCREATEINPUT("",$GR_SKILL_POSX+164,$GR_SKILL_POSY+165,60,21,BITOR($GUI_SS_DEFAULT_INPUT,$ES_RIGHT,$ES_NUMBER))
$LABELSKILL8A=GUICTRLCREATELABEL("ms",$GR_SKILL_POSX+234,$GR_SKILL_POSY+170)
$ACTIVSKILL[9]=GUICTRLCREATECHECKBOX("9",$GR_SKILL_POSX+5,$GR_SKILL_POSY+185)
$DELAYSKILL[9]=GUICTRLCREATEINPUT("",$GR_SKILL_POSX+35,$GR_SKILL_POSY+185,60,21,BITOR($GUI_SS_DEFAULT_INPUT,$ES_RIGHT,$ES_NUMBER))
$CASTINGSKILL[9]=GUICTRLCREATEINPUT("",$GR_SKILL_POSX+100,$GR_SKILL_POSY+185,60,21,BITOR($GUI_SS_DEFAULT_INPUT,$ES_RIGHT,$ES_NUMBER))
$COOLDOWNSKILL[9]=GUICTRLCREATEINPUT("",$GR_SKILL_POSX+164,$GR_SKILL_POSY+185,60,21,BITOR($GUI_SS_DEFAULT_INPUT,$ES_RIGHT,$ES_NUMBER))
$LABELSKILL9A=GUICTRLCREATELABEL("ms",$GR_SKILL_POSX+234,$GR_SKILL_POSY+190)
$ACTIVSKILL[10]=GUICTRLCREATECHECKBOX("10",$GR_SKILL_POSX+5,$GR_SKILL_POSY+205)
$DELAYSKILL[10]=GUICTRLCREATEINPUT("",$GR_SKILL_POSX+35,$GR_SKILL_POSY+205,60,21,BITOR($GUI_SS_DEFAULT_INPUT,$ES_RIGHT,$ES_NUMBER))
$CASTINGSKILL[10]=GUICTRLCREATEINPUT("",$GR_SKILL_POSX+100,$GR_SKILL_POSY+205,60,21,BITOR($GUI_SS_DEFAULT_INPUT,$ES_RIGHT,$ES_NUMBER))
$COOLDOWNSKILL[10]=GUICTRLCREATEINPUT("",$GR_SKILL_POSX+164,$GR_SKILL_POSY+205,60,21,BITOR($GUI_SS_DEFAULT_INPUT,$ES_RIGHT,$ES_NUMBER))
$LABELSKILL10A=GUICTRLCREATELABEL("ms",$GR_SKILL_POSX+234,$GR_SKILL_POSY+210)
$ACTIVSKILL[11]=GUICTRLCREATECHECKBOX("P",$GR_SKILL_POSX+5,$GR_SKILL_POSY+225)
$DELAYSKILL[11]=GUICTRLCREATEINPUT("",$GR_SKILL_POSX+35,$GR_SKILL_POSY+225,60,21,BITOR($GUI_SS_DEFAULT_INPUT,$ES_RIGHT,$ES_NUMBER))
$CASTINGSKILL[11]=GUICTRLCREATEINPUT("",$GR_SKILL_POSX+100,$GR_SKILL_POSY+225,60,21,BITOR($GUI_SS_DEFAULT_INPUT,$ES_RIGHT,$ES_NUMBER))
$LABELSKILL11A=GUICTRLCREATELABEL("s",$GR_SKILL_POSX+234,$GR_SKILL_POSY+230)
#EndRegion
#Region Special UI & Variable
GLOBAL $DELAYSPECIAL
GLOBAL $TIMERSPECIAL
GLOBAL $TIMEDIFFSPECIAL
GLOBAL $TIMELEFTSPECIAL
GLOBAL $SPECIAL
GLOBAL $AUTOSPECIAL
GLOBAL $BTNHELPSPECIAL
LOCAL $GR_SPECIAL_POSX=6
LOCAL $GR_SPECIAL_POSY=260
GUICTRLCREATEGROUP("",$GR_SPECIAL_POSX,$GR_SPECIAL_POSY,125,70)
$TIMELEFTSPECIAL=GUICTRLCREATELABEL("",$GR_SPECIAL_POSX+65,$GR_SPECIAL_POSY+8,60,21)
$BTNHELPSPECIAL=GUICTRLCREATEBUTTON("?",$GR_SPECIAL_POSX+110,$GR_SPECIAL_POSY)
$AUTOSPECIAL=GUICTRLCREATECHECKBOX("Special",$GR_SPECIAL_POSX+5,$GR_SPECIAL_POSY)
$SPECIAL=GUICTRLCREATEINPUT("",$GR_SPECIAL_POSX+5,$GR_SPECIAL_POSY+25,115,21,$GUI_SS_DEFAULT_INPUT)
$LABELSPECIAL1=GUICTRLCREATELABEL("delay (s)",$GR_SPECIAL_POSX+5,$GR_SPECIAL_POSY+47)
$DELAYSPECIAL=GUICTRLCREATEINPUT("",$GR_SPECIAL_POSX+60,$GR_SPECIAL_POSY+45,60,21,BITOR($GUI_SS_DEFAULT_INPUT,$ES_RIGHT,$ES_NUMBER))
GUICTRLCREATEGROUP("",-99,-99,1,1)
#EndRegion
#Region MouseLR UI & Variable
GLOBAL $DELAYMOUSEL
GLOBAL $TIMERMOUSEL
GLOBAL $TIMEDIFFMOUSEL
GLOBAL $DELAYMOUSER
GLOBAL $TIMERMOUSER
GLOBAL $TIMEDIFFMOUSER
LOCAL $GR_MOUSELR_POSX=140
LOCAL $GR_MOUSELR_POSY=260
GUICTRLCREATEGROUP("MouseLR",$GR_MOUSELR_POSX,$GR_MOUSELR_POSY,125,70)
$LABELMOUSELR=GUICTRLCREATELABEL("delay (s)",$GR_MOUSELR_POSX+75,$GR_MOUSELR_POSY+10)
$AUTOMOUSEL=GUICTRLCREATECHECKBOX("Left",$GR_MOUSELR_POSX+5,$GR_MOUSELR_POSY+25)
$AUTOMOUSER=GUICTRLCREATECHECKBOX("Right",$GR_MOUSELR_POSX+5,$GR_MOUSELR_POSY+45)
$DELAYMOUSEL=GUICTRLCREATEINPUT("",$GR_MOUSELR_POSX+60,$GR_MOUSELR_POSY+25,60,21,BITOR($GUI_SS_DEFAULT_INPUT,$ES_RIGHT,$ES_NUMBER))
$DELAYMOUSER=GUICTRLCREATEINPUT("",$GR_MOUSELR_POSX+60,$GR_MOUSELR_POSY+45,60,21,BITOR($GUI_SS_DEFAULT_INPUT,$ES_RIGHT,$ES_NUMBER))
GUICTRLCREATEGROUP("",-99,-99,1,1)
#EndRegion
#Region Trap UI & Variable
GLOBAL $AUTOTRAP[5]
GLOBAL $DELAYTRAP[5]
GLOBAL $CASTINGTRAP[5]
GLOBAL $TIMERTRAP[5]
GLOBAL $TIMEDIFFTRAP[5]
GLOBAL $POSX_TRAP[5]
GLOBAL $POSY_TRAP[5]
GLOBAL $AUTOEXPLOSION
LOCAL $GR_TRAP_POSX=6
LOCAL $GR_TRAP_POSY=330
GUICTRLCREATEGROUP("Trap",$GR_TRAP_POSX,$GR_TRAP_POSY,260,135)
$LABELTRAP1A=GUICTRLCREATELABEL("pos x",$GR_TRAP_POSX+35,$GR_TRAP_POSY+10)
$LABELTRAP1B=GUICTRLCREATELABEL("pos y",$GR_TRAP_POSX+90,$GR_TRAP_POSY+10)
$LABELTRAP1C=GUICTRLCREATELABEL("delay (s)",$GR_TRAP_POSX+145,$GR_TRAP_POSY+10)
$LABELTRAP1D=GUICTRLCREATELABEL("casting (s)",$GR_TRAP_POSX+200,$GR_TRAP_POSY+10)
$AUTOTRAP[1]=GUICTRLCREATECHECKBOX("1",$GR_TRAP_POSX+5,$GR_TRAP_POSY+25)
$POSX_TRAP[1]=GUICTRLCREATEINPUT("",$GR_TRAP_POSX+35,$GR_TRAP_POSY+25,50,21,BITOR($GUI_SS_DEFAULT_INPUT,$ES_RIGHT,$ES_NUMBER))
$POSY_TRAP[1]=GUICTRLCREATEINPUT("",$GR_TRAP_POSX+90,$GR_TRAP_POSY+25,50,21,BITOR($GUI_SS_DEFAULT_INPUT,$ES_RIGHT,$ES_NUMBER))
$DELAYTRAP[1]=GUICTRLCREATEINPUT("",$GR_TRAP_POSX+145,$GR_TRAP_POSY+25,50,21,BITOR($GUI_SS_DEFAULT_INPUT,$ES_RIGHT,$ES_NUMBER))
$CASTINGTRAP[1]=GUICTRLCREATEINPUT("",$GR_TRAP_POSX+200,$GR_TRAP_POSY+25,50,21,BITOR($GUI_SS_DEFAULT_INPUT,$ES_RIGHT,$ES_NUMBER))
$AUTOTRAP[2]=GUICTRLCREATECHECKBOX("2",$GR_TRAP_POSX+5,$GR_TRAP_POSY+45)
$POSX_TRAP[2]=GUICTRLCREATEINPUT("",$GR_TRAP_POSX+35,$GR_TRAP_POSY+45,50,21,BITOR($GUI_SS_DEFAULT_INPUT,$ES_RIGHT,$ES_NUMBER))
$POSY_TRAP[2]=GUICTRLCREATEINPUT("",$GR_TRAP_POSX+90,$GR_TRAP_POSY+45,50,21,BITOR($GUI_SS_DEFAULT_INPUT,$ES_RIGHT,$ES_NUMBER))
$DELAYTRAP[2]=GUICTRLCREATEINPUT("",$GR_TRAP_POSX+145,$GR_TRAP_POSY+45,50,21,BITOR($GUI_SS_DEFAULT_INPUT,$ES_RIGHT,$ES_NUMBER))
$CASTINGTRAP[2]=GUICTRLCREATEINPUT("",$GR_TRAP_POSX+200,$GR_TRAP_POSY+45,50,21,BITOR($GUI_SS_DEFAULT_INPUT,$ES_RIGHT,$ES_NUMBER))
$AUTOTRAP[3]=GUICTRLCREATECHECKBOX("3",$GR_TRAP_POSX+5,$GR_TRAP_POSY+65)
$POSX_TRAP[3]=GUICTRLCREATEINPUT("",$GR_TRAP_POSX+35,$GR_TRAP_POSY+65,50,21,BITOR($GUI_SS_DEFAULT_INPUT,$ES_RIGHT,$ES_NUMBER))
$POSY_TRAP[3]=GUICTRLCREATEINPUT("",$GR_TRAP_POSX+90,$GR_TRAP_POSY+65,50,21,BITOR($GUI_SS_DEFAULT_INPUT,$ES_RIGHT,$ES_NUMBER))
$DELAYTRAP[3]=GUICTRLCREATEINPUT("",$GR_TRAP_POSX+145,$GR_TRAP_POSY+65,50,21,BITOR($GUI_SS_DEFAULT_INPUT,$ES_RIGHT,$ES_NUMBER))
$CASTINGTRAP[3]=GUICTRLCREATEINPUT("",$GR_TRAP_POSX+200,$GR_TRAP_POSY+65,50,21,BITOR($GUI_SS_DEFAULT_INPUT,$ES_RIGHT,$ES_NUMBER))
$AUTOTRAP[4]=GUICTRLCREATECHECKBOX("4",$GR_TRAP_POSX+5,$GR_TRAP_POSY+85)
$POSX_TRAP[4]=GUICTRLCREATEINPUT("",$GR_TRAP_POSX+35,$GR_TRAP_POSY+85,50,21,BITOR($GUI_SS_DEFAULT_INPUT,$ES_RIGHT,$ES_NUMBER))
$POSY_TRAP[4]=GUICTRLCREATEINPUT("",$GR_TRAP_POSX+90,$GR_TRAP_POSY+85,50,21,BITOR($GUI_SS_DEFAULT_INPUT,$ES_RIGHT,$ES_NUMBER))
$DELAYTRAP[4]=GUICTRLCREATEINPUT("",$GR_TRAP_POSX+145,$GR_TRAP_POSY+85,50,21,BITOR($GUI_SS_DEFAULT_INPUT,$ES_RIGHT,$ES_NUMBER))
$CASTINGTRAP[4]=GUICTRLCREATEINPUT("",$GR_TRAP_POSX+200,$GR_TRAP_POSY+85,50,21,BITOR($GUI_SS_DEFAULT_INPUT,$ES_RIGHT,$ES_NUMBER))
$AUTOEXPLOSION=GUICTRLCREATECHECKBOX("Auto Explosion: slot 5; Trap: slot 1 - 4",$GR_TRAP_POSX+5,$GR_TRAP_POSY+110)
GUICTRLCREATEGROUP("",-99,-99,1,1)
#EndRegion
#Region SpaceA & Variable
LOCAL $GR_SPACEA_POSX=280
LOCAL $GR_SPACEA_POSY=60
GUICTRLCREATEGROUP("",$GR_SPACEA_POSX,$GR_SPACEA_POSY,165,60)
$ACTIVSKILL[12]=GUICTRLCREATECHECKBOX("Space",$GR_SPACEA_POSX+6,$GR_SPACEA_POSY+10)
$DELAYSKILL[12]=GUICTRLCREATEINPUT("",$GR_SPACEA_POSX+60,$GR_SPACEA_POSY+10,60,21,BITOR($GUI_SS_DEFAULT_INPUT,$ES_RIGHT,$ES_NUMBER))
$LABELSPACEA1A=GUICTRLCREATELABEL("s",$GR_SPACEA_POSX+130,$GR_SPACEA_POSY+10)
$ACTIVSKILL[13]=GUICTRLCREATECHECKBOX("A",$GR_SPACEA_POSX+6,$GR_SPACEA_POSY+35)
$DELAYSKILL[13]=GUICTRLCREATEINPUT("",$GR_SPACEA_POSX+60,$GR_SPACEA_POSY+35,60,21,BITOR($GUI_SS_DEFAULT_INPUT,$ES_RIGHT,$ES_NUMBER))
$LABELSPACEA1B=GUICTRLCREATELABEL("ms",$GR_SPACEA_POSX+130,$GR_SPACEA_POSY+35)
#EndRegion
#Region Gift UI & Variable Ver 2.0
GLOBAL $DELAYGIFT=1
GLOBAL $TIMERGIFT=-1
GLOBAL $TIMEDIFFGIFT
GLOBAL $TIMELEFTGIFT
GLOBAL $ERRORGIFT
GLOBAL $GIFTSCRIPTON=FALSE
LOCAL $GR_GIFT_POSX=280
LOCAL $GR_GIFT_POSY=122
GUICTRLCREATEGROUP("",$GR_GIFT_POSX,$GR_GIFT_POSY,165,208)
$LABELERRGIFT=GUICTRLCREATELABEL("",$GR_GIFT_POSX+5,$GR_GIFT_POSY+20,30,25)
GUICTRLSETCOLOR(-1,16711680)
$TIMELEFTGIFT=GUICTRLCREATELABEL("",$GR_GIFT_POSX+65,$GR_GIFT_POSY+15,90,25)
$AUTOGIFT=GUICTRLCREATECHECKBOX("Gift",$GR_GIFT_POSX+5,$GR_GIFT_POSY)
$LABELGIFT1E=GUICTRLCREATELABEL("delay gift",$GR_GIFT_POSX+10,$GR_GIFT_POSY+35)
$LABELGIFT1F=GUICTRLCREATELABEL("min",$GR_GIFT_POSX+125,$GR_GIFT_POSY+35)
$DELAYGIFT=GUICTRLCREATEINPUT("",$GR_GIFT_POSX+65,$GR_GIFT_POSY+33,50,21,BITOR($GUI_SS_DEFAULT_INPUT,$ES_RIGHT,$ES_NUMBER))
$GIFTSCRIPT=GUICTRLCREATEEDIT("",$GR_GIFT_POSX+10,$GR_GIFT_POSY+60,145,140,BITOR($ES_AUTOVSCROLL,$ES_AUTOHSCROLL,$ES_MULTILINE,$ES_WANTRETURN))
GUICTRLCREATEGROUP("",-99,-99,1,1)
#EndRegion
#Region Manual UI & Variable
GLOBAL $DELAYMANUAL
GLOBAL $TIMERMANUAL=-1
GLOBAL $TIMEDIFFMANUAL
GLOBAL $TIMELEFTMANUAL
GLOBAL $BTNHELPMANUAL
LOCAL $GR_MANUAL_POSX=280
LOCAL $GR_MANUAL_POSY=330
GUICTRLCREATEGROUP("",$GR_MANUAL_POSX,$GR_MANUAL_POSY,165,105)
$AUTOMANUAL=GUICTRLCREATECHECKBOX("Manual",$GR_MANUAL_POSX+5,$GR_MANUAL_POSY)
$TIMELEFTMANUAL=GUICTRLCREATELABEL("",$GR_MANUAL_POSX+65,$GR_MANUAL_POSY+15,90,25)
$LABELMANUAL1=GUICTRLCREATELABEL("x:",$GR_MANUAL_POSX+5,$GR_MANUAL_POSY+39)
$LABELMANUAL2=GUICTRLCREATELABEL("y:",$GR_MANUAL_POSX+57,$GR_MANUAL_POSY+39)
$LABELMANUAL3=GUICTRLCREATELABEL("K:",$GR_MANUAL_POSX+112,$GR_MANUAL_POSY+39)
$MANUAL_POSX=GUICTRLCREATEINPUT("",$GR_MANUAL_POSX+15,$GR_MANUAL_POSY+36,40,21,BITOR($GUI_SS_DEFAULT_INPUT,$ES_RIGHT,$ES_NUMBER))
$MANUAL_POSY=GUICTRLCREATEINPUT("",$GR_MANUAL_POSX+67,$GR_MANUAL_POSY+36,40,21,BITOR($GUI_SS_DEFAULT_INPUT,$ES_RIGHT,$ES_NUMBER))
$MANUAL_CONFIRMKEY=GUICTRLCREATEINPUT("",$GR_MANUAL_POSX+122,$GR_MANUAL_POSY+36,40,21)
$LABELMANUAL4=GUICTRLCREATELABEL("delay",$GR_MANUAL_POSX+14,$GR_MANUAL_POSY+63)
$DELAYMANUAL=GUICTRLCREATEINPUT("",$GR_MANUAL_POSX+54,$GR_MANUAL_POSY+58,60,21,BITOR($GUI_SS_DEFAULT_INPUT,$ES_RIGHT,$ES_NUMBER))
$LABELMANUAL5=GUICTRLCREATELABEL("min",$GR_MANUAL_POSX+119,$GR_MANUAL_POSY+63)
$LABELMANUAL6=GUICTRLCREATELABEL("casting",$GR_MANUAL_POSX+14,$GR_MANUAL_POSY+82)
$CASTINGMANUAL=GUICTRLCREATEINPUT("",$GR_MANUAL_POSX+54,$GR_MANUAL_POSY+77,60,21,BITOR($GUI_SS_DEFAULT_INPUT,$ES_RIGHT,$ES_NUMBER))
$LABELMANUAL6=GUICTRLCREATELABEL("s",$GR_MANUAL_POSX+119,$GR_MANUAL_POSY+82)
$BTNHELPMANUAL=GUICTRLCREATEBUTTON("?",$GR_MANUAL_POSX+148,$GR_MANUAL_POSY+78)
GUICTRLCREATEGROUP("",-99,-99,1,1)
#EndRegion
#Region Coordinate
GLOBAL $COORDREL
GLOBAL $COORDABS
GLOBAL $MOUSECOORDMODE=-1
LOCAL $GR_COORD_POSX=280
LOCAL $GR_COORD_POSY=433
GUICTRLCREATEGROUP("",$GR_COORD_POSX,$GR_COORD_POSY,165,35)
$COORDREL=GUICTRLCREATERADIO("relative",$GR_COORD_POSX+10,$GR_COORD_POSY+10)
$COORDABS=GUICTRLCREATERADIO("absolute",$GR_COORD_POSX+90,$GR_COORD_POSY+10)
#EndRegion
#Region Control UI & Variable
GLOBAL $BTNLOADPESET
GLOBAL $PRESETFILE
GLOBAL $ARRAYPRESET
GLOBAL $START=FALSE
GLOBAL $TIMERQUIT
GLOBAL $TIMEDIFFQUIT
GLOBAL $GUI_TIMEDISPLAY
GLOBAL $TIMEDISPLAY=FALSE
LOCAL $GR_CONTROL_POSX=280
LOCAL $GR_CONTROL_POSY=463
GUICTRLCREATEGROUP("",$GR_CONTROL_POSX,$GR_CONTROL_POSY,165,90)
$BTNLOADPRESET=GUICTRLCREATEBUTTON("Load preset",$GR_CONTROL_POSX+5,$GR_CONTROL_POSY+10,75,25)
$BTNSAVEPRESET=GUICTRLCREATEBUTTON("Save preset",$GR_CONTROL_POSX+85,$GR_CONTROL_POSY+10,75,25)
$BTNRUNPAUSE=GUICTRLCREATEBUTTON("Run",$GR_CONTROL_POSX+5,$GR_CONTROL_POSY+40,45,45)
$LABELSTATE=GUICTRLCREATELABEL("State: ",$GR_CONTROL_POSX+60,$GR_CONTROL_POSY+40,100,21)
$LABELMODE=GUICTRLCREATELABEL("Mode: ",$GR_CONTROL_POSX+60,$GR_CONTROL_POSY+55,100,21)
$GUI_TIMEDISPLAY=GUICTRLCREATECHECKBOX("display time",$GR_CONTROL_POSX+60,$GR_CONTROL_POSY+67)
GUICTRLCREATEGROUP("",-99,-99,1,1)
#EndRegion
#Region RoarMap UI & Variable
GLOBAL $TIMERROARMAP
GLOBAL $TIMEDIFFROARMAP
LOCAL $GR_ROARMAP_POSX=6
LOCAL $GR_ROARMAP_POSY=463
GUICTRLCREATEGROUP("",$GR_ROARMAP_POSX,$GR_ROARMAP_POSY,260,90)
$AUTOROARMAP=GUICTRLCREATECHECKBOX("Roar/Map",$GR_ROARMAP_POSX+5,$GR_ROARMAP_POSY+8)
$LABELROARMAP1A=GUICTRLCREATELABEL("break (s)",$GR_ROARMAP_POSX+5,$GR_ROARMAP_POSY+28)
$BREAKROARMAP=GUICTRLCREATEINPUT("",$GR_ROARMAP_POSX+50,$GR_ROARMAP_POSY+28,40,21,BITOR($GUI_SS_DEFAULT_INPUT,$ES_RIGHT,$ES_NUMBER))
$REPEATROARMAP=GUICTRLCREATECHECKBOX("repeat",$GR_ROARMAP_POSX+5,$GR_ROARMAP_POSY+45)
$LABELROARMAP1B=GUICTRLCREATELABEL("delay (s)",$GR_ROARMAP_POSX+5,$GR_ROARMAP_POSY+65)
$DELAYROARMAP=GUICTRLCREATEINPUT("",$GR_ROARMAP_POSX+50,$GR_ROARMAP_POSY+65,40,21,BITOR($GUI_SS_DEFAULT_INPUT,$ES_RIGHT,$ES_NUMBER))
$ROARMAPTEXT=GUICTRLCREATEEDIT("",$GR_ROARMAP_POSX+95,$GR_ROARMAP_POSY+10,160,75,BITOR($ES_AUTOVSCROLL,$ES_AUTOHSCROLL,$ES_MULTILINE,$ES_WANTRETURN))
#EndRegion
#Region Logo
GUICTRLCREATEGRAPHIC(393,10,50,50,0)
GUICTRLSETBKCOLOR(-1,15761536)
GUICTRLSETGRAPHIC(-1,$GUI_GR_COLOR,2167412,2167412)
LOCAL $LOGOX=5
LOCAL $LOGOY=8
GUICTRLSETGRAPHIC(-1,$GUI_GR_RECT,$LOGOX,$LOGOY,10,3)
GUICTRLSETGRAPHIC(-1,$GUI_GR_RECT,$LOGOX+8,$LOGOY,5,35)
GUICTRLSETGRAPHIC(-1,$GUI_GR_RECT,$LOGOX,$LOGOY+32,10,3)
GUICTRLSETGRAPHIC(-1,$GUI_GR_RECT,$LOGOX+15,$LOGOY+32,25,3)
#EndRegion
GUICTRLSETCOLOR(-1,16711680)
;==============SHREK===========
GUISetFont(12,400)
$_Auto_Skill_Tab = GUICtrlCreateTabItem("Total")
GUISetFont(11,400)

$idCheckbox_Pickup = GUICtrlCreateCheckbox("Tự động nhặt đồ", 10, 260, 150, 25); Checkbox cho phép nhặt đồ hay không
$idCheckbox_Pickup_Special = GUICtrlCreateCheckbox("Nhặt items đặc biệt", 160, 260, 150, 25); Checkbox cho phép nhặt đồ hay không
$idButton_Pause = GUICtrlCreateButton("Stop (F1)", 5, 290, 150, 25)
;Nút Thoát Chương trình
$idButton_Close = GUICtrlCreateButton("Close", 165, 290, 150, 25)
$idLabel_Showmode=GUICtrlCreateLabel("Status:",10,320, 300, 25)

;Bat dau tao Tab va Item cho Tab


GUISetFont(11,400)
;Tab Auto skill Normal
$_Auto_Skill_Tab = GUICtrlCreateTabItem("Skill")
   $_idLabel_F2 = GUICtrlCreateLabel("Auto dãy skill dưới (F2)", 10, 50, 200, 25)
   $idButton_StartF7 = GUICtrlCreateButton("Start", 230, 50, 85, 25)
   $_idLabel_F3 = GUICtrlCreateLabel("Auto dãy Skill trên (F3)", 10, 90, 200, 25)
   $idButton_StartF8 = GUICtrlCreateButton("Start", 230, 90, 85, 25)
   $_idLabel_F4 = GUICtrlCreateLabel("Auto 2 dãy Skill (F4)", 10, 130, 200, 25)
   $idButton_StartF9 = GUICtrlCreateButton("Start", 230, 130, 85, 25)
   $_idLabel_Meditation = GUICtrlCreateLabel("Vận khí sau", 10, 170, 80, 25)
   $_idTxt_Meditation = GUICtrlCreateInput(0,110,170,70,25,$ES_NUMBER)
   $_idLabel_Meditation1 = GUICtrlCreateLabel("Phút (0=No)", 190, 170, 90, 25)
   $_idCheckbox_Myself = GUICtrlCreateCheckbox("Tự chọn bản thân luyện skill", 10, 200, 200, 25)
   $_idCheckbox_Z_Press = GUICtrlCreateCheckbox("Nhấn Z khi vào Quyết", 10, 230, 200, 25)
GUISetFont(12,400)
;Tab Auto Farming
$_Auto_Farm_Tab = GUICtrlCreateTabItem("Farm")
   GUISetFont(11,400)
   $_idCheckbox_Zombie = GUICtrlCreateCheckbox("Bỏ Zombie", 10, 50, 90, 25); Không đánh Zombie nếu chọn
   $_idCheckbox_SummonPet = GUICtrlCreateCheckbox("Gọi Pet sau hồi sinh", 150, 50, 150, 25); Gọi pet sau hồi sinh
   $_idCheckbox_PetCharge = GUICtrlCreateCheckbox("Nuôi Pet (Default 240 minutes)", 10, 80, 215, 25); Chọn nuôi pet
   $_idTxt_PetTime = GUICtrlCreateInput(240,260,80,50,25,$ES_NUMBER)
   $_idGroup_Revive = GUICtrlCreateGroup("Hồi sinh/ Revive", 5, 110, 310, 50)
   ;GUICtrlSetColor($_idGroup_Revive ,$COLOR_RED)
   $_idOpt_HoisinhHD = GUICtrlCreateRadio("Hoa đà", 10, 130, 70, 25)
   GUICtrlSetState($_idOpt_HoisinhHD, $GUI_CHECKED)
   $_idOpt_HoisinhTaiCho = GUICtrlCreateRadio("Tại chổ", 120, 130, 70, 25)
   $_idOpt_KhongHS = GUICtrlCreateRadio("Không", 230, 130, 60, 25)
   GUICtrlCreateGroup("", -99, -99, 1, 1)
   $_idLabelPetTime = GUICtrlCreateLabel("Kiểm tra và bật Pet sau",10, 170, 160, 25)
   $_idTxtPetTime = GUICtrlCreateInput(21,175,165,30,25,$ES_NUMBER)
   $_idLabelPhut = GUICtrlCreateLabel("Phút (0=No)",210, 170, 80, 25)
   $_idCheckbox_ActiveSkill = GUICtrlCreateCheckbox("Chỉ đánh chiêu thức kỹ", 10, 200, 215, 25)
   $idButton_Train=GUICtrlCreateButton("Star Farm Event (F6-F7)",5, 230, 310,25)
;Tab Auto Refinement
GUISetFont(12,400)
$_Auto_Refinement_Tab = GUICtrlCreateTabItem("Refinement")
   GUISetFont(11,400)
   $_idLabelRefNum = GUICtrlCreateLabel("Số lượng",10, 55, 60, 25)
   $_idTxtRefNum = GUICtrlCreateInput(50,80,50,30,25,$ES_NUMBER)
   $_idLabelRefLvl = GUICtrlCreateLabel("Ép đến (Level)",150, 55, 100, 25)
   $_idTxtRefLvl = GUICtrlCreateInput(7,260,50,30,25,$ES_NUMBER)
   $_idGroup_RefType = GUICtrlCreateGroup("Refinement Type", 5, 90, 310, 50)
   $_idOpt_Chikung = GUICtrlCreateRadio("Chikung", 10, 105, 80, 30)
   GUICtrlSetState($_idOpt_Chikung, $GUI_CHECKED)
   $_idOpt_Warrior = GUICtrlCreateRadio("Warrior", 130, 105, 80, 30)
   $_idOpt_NoneType = GUICtrlCreateRadio("None", 250, 105, 60, 30)
   GUICtrlCreateGroup("", -99, -99, 1, 1)
   $_idButtonRef = GUICtrlCreateButton("Bắt đầu ép...(F8)",5,140,310,25)
;Tab Auto Login
GUISetFont(12,400)
$_Auto_Login_Tab = GUICtrlCreateTabItem("Login")
   GUISetFont(11,400)
   $_idCheckbox_Relog = GUICtrlCreateCheckbox("Tự động đăng nhập khi bị GM đá",10, 50, 280,25)
   $_idLabelPass1 = GUICtrlCreateLabel("Pass 1:", 10, 80, 50, 25)
   $_idTxtPass1 = GUICtrlCreateInput("", 65, 80, 250, 25,$ES_PASSWORD)
   $_idLabelPass2 = GUICtrlCreateLabel("Pass 2:", 10, 110, 50, 25)
   $_idTxtPass2 = GUICtrlCreateInput("", 65, 110, 250, 25,$ES_PASSWORD)
   $_idGroup_SelectChar = GUICtrlCreateGroup("Chọn nhân vật", 5, 150, 310, 50)
   $_idOpt_1stChar = GUICtrlCreateRadio("Nhân vật 1", 10, 165, 90, 30)
   GUICtrlSetState($_idOpt_1stChar, $GUI_CHECKED)
   $_idOpt_2ndChar = GUICtrlCreateRadio("Nhân Vật 2", 115, 165, 90, 30)
   $_idOpt_3rdChar = GUICtrlCreateRadio("Nhân vật 3", 220, 165, 90, 30)
   GUICtrlCreateGroup("", -99, -99, 1, 1)

;=============END SHREK====================
GUISETSTATE(@SW_SHOW)
#EndRegion ### END Koda GUI section ###
#Region func
FUNC SEC2TIME($NR_SEC,$MODE)
$SEC2TIME_HOUR=INT($NR_SEC/3600)
$SEC2TIME_MIN=INT(($NR_SEC-$SEC2TIME_HOUR*3600)/60)
$SEC2TIME_SEC=$NR_SEC-$SEC2TIME_HOUR*3600-$SEC2TIME_MIN*60
IF $MODE="full" THEN
RETURN STRINGFORMAT("%02d:%02d:%02d",$SEC2TIME_HOUR,$SEC2TIME_MIN,$SEC2TIME_SEC)
ELSE
IF (($SEC2TIME_HOUR=0)AND ($SEC2TIME_MIN=0))THEN
RETURN STRINGFORMAT("%02d s",$SEC2TIME_SEC)
ELSEIF (($SEC2TIME_HOUR=0)AND ($SEC2TIME_MIN>0))THEN
RETURN STRINGFORMAT("%02d:%02d",$SEC2TIME_MIN,$SEC2TIME_SEC)
ELSE
RETURN STRINGFORMAT("%02d:%02d:%02d",$SEC2TIME_HOUR,$SEC2TIME_MIN,$SEC2TIME_SEC)
ENDIF
ENDIF
ENDFUNC
FUNC SORTDELAY()
$POS=0
FOR $I=1 TO 10
$DELAYSORTED[0][$I]=GUICTRLREAD($ACTIVSKILL[$I])
$DELAYSORTED[1][$I]=$SKILL[$I]
$DELAYSORTED[2][$I]=GUICTRLREAD($DELAYSKILL[$I])
$DELAYSORTED[3][$I]=GUICTRLREAD($CASTINGSKILL[$I])
$DELAYSORTED[4][$I]=GUICTRLREAD($COOLDOWNSKILL[$I])
NEXT
DO
$SWAP=0
FOR $I=1 TO 9
IF $DELAYSORTED[2][$I]<$DELAYSORTED[2][$I+1]THEN
$SWAP=1
$TEMP0=$DELAYSORTED[0][$I]
$TEMP1=$DELAYSORTED[1][$I]
$TEMP2=$DELAYSORTED[2][$I]
$TEMP3=$DELAYSORTED[3][$I]
$TEMP4=$DELAYSORTED[4][$I]
$DELAYSORTED[0][$I]=$DELAYSORTED[0][$I+1]
$DELAYSORTED[1][$I]=$DELAYSORTED[1][$I+1]
$DELAYSORTED[2][$I]=$DELAYSORTED[2][$I+1]
$DELAYSORTED[3][$I]=$DELAYSORTED[3][$I+1]
$DELAYSORTED[4][$I]=$DELAYSORTED[4][$I+1]
$DELAYSORTED[0][$I+1]=$TEMP0
$DELAYSORTED[1][$I+1]=$TEMP1
$DELAYSORTED[2][$I+1]=$TEMP2
$DELAYSORTED[3][$I+1]=$TEMP3
$DELAYSORTED[4][$I+1]=$TEMP4
ENDIF
NEXT
UNTIL $SWAP=0
ENDFUNC
FUNC LOADPRESET()
_FILEREADTOARRAY($PRESETFILE,$ARRAYPRESET)
CLEARGUI()
FOR $I=1 TO UBOUND($ARRAYPRESET)-1
LOCAL $IDENTIFIER=STRINGSPLIT($ARRAYPRESET[$I],":")
SELECT
CASE $IDENTIFIER[1]="gift_pos1"
LOCAL $PARAMETER=STRINGSPLIT($IDENTIFIER[2],",")
GUICTRLSETSTATE($GIFT_POS1X,$PARAMETER[1])
GUICTRLSETSTATE($GIFT_POS1Y,$PARAMETER[2])
CASE $IDENTIFIER[1]="gift_pos2"
LOCAL $PARAMETER=STRINGSPLIT($IDENTIFIER[2],",")
GUICTRLSETSTATE($GIFT_POS2X,$PARAMETER[1])
GUICTRLSETSTATE($GIFT_POS2Y,$PARAMETER[2])
CASE $IDENTIFIER[1]="manual_pos"
LOCAL $PARAMETER=STRINGSPLIT($IDENTIFIER[2],",")
GUICTRLSETSTATE($MANUAL_POSX,$PARAMETER[1])
GUICTRLSETSTATE($MANUAL_POSY,$PARAMETER[2])
CASE $IDENTIFIER[1]="p"
LOCAL $PARAMETER=STRINGSPLIT($IDENTIFIER[2],",")
GUICTRLSETSTATE($ACTIVSKILL[11],$PARAMETER[1])
GUICTRLSETDATA($DELAYSKILL[11],$PARAMETER[2])
GUICTRLSETDATA($CASTINGSKILL[11],$PARAMETER[3])
CASE $IDENTIFIER[1]="space"
LOCAL $PARAMETER=STRINGSPLIT($IDENTIFIER[2],",")
GUICTRLSETSTATE($ACTIVSKILL[12],$PARAMETER[1])
GUICTRLSETDATA($DELAYSKILL[12],$PARAMETER[2])
CASE $IDENTIFIER[1]="a"
LOCAL $PARAMETER=STRINGSPLIT($IDENTIFIER[2],",")
GUICTRLSETSTATE($ACTIVSKILL[13],$PARAMETER[1])
GUICTRLSETDATA($DELAYSKILL[13],$PARAMETER[2])
CASE $IDENTIFIER[1]="special"
LOCAL $PARAMETER=STRINGSPLIT($IDENTIFIER[2],",")
GUICTRLSETSTATE($AUTOSPECIAL,$PARAMETER[1])
GUICTRLSETDATA($SPECIAL,$PARAMETER[2])
GUICTRLSETDATA($DELAYSPECIAL,$PARAMETER[3])
CASE $IDENTIFIER[1]="mouseL"
LOCAL $PARAMETER=STRINGSPLIT($IDENTIFIER[2],",")
GUICTRLSETSTATE($AUTOMOUSEL,$PARAMETER[1])
GUICTRLSETDATA($DELAYMOUSEL,$PARAMETER[2])
CASE $IDENTIFIER[1]="mouseR"
LOCAL $PARAMETER=STRINGSPLIT($IDENTIFIER[2],",")
GUICTRLSETSTATE($AUTOMOUSER,$PARAMETER[1])
GUICTRLSETDATA($DELAYMOUSER,$PARAMETER[2])
CASE $IDENTIFIER[1]="trap1" OR $IDENTIFIER[1]="trap2" OR $IDENTIFIER[1]="trap3" OR $IDENTIFIER[1]="trap4"
LOCAL $PARAMETER=STRINGSPLIT($IDENTIFIER[2],",")
LOCAL $IDX=STRINGRIGHT($IDENTIFIER[1],1)
GUICTRLSETSTATE($AUTOTRAP[$IDX],$PARAMETER[1])
GUICTRLSETDATA($POSX_TRAP[$IDX],$PARAMETER[2])
GUICTRLSETDATA($POSY_TRAP[$IDX],$PARAMETER[3])
GUICTRLSETDATA($DELAYTRAP[$IDX],$PARAMETER[4])
GUICTRLSETDATA($CASTINGTRAP[$IDX],$PARAMETER[5])
CASE $IDENTIFIER[1]="explosion"
LOCAL $PARAMETER=STRINGSPLIT($IDENTIFIER[2],",")
GUICTRLSETSTATE($AUTOEXPLOSION,$PARAMETER[1])
CASE $IDENTIFIER[1]="gift"
LOCAL $PARAMETER=STRINGSPLIT($IDENTIFIER[2],",")
GUICTRLSETSTATE($AUTOGIFT,$PARAMETER[1])
GUICTRLSETDATA($DELAYGIFT,$PARAMETER[2])
CASE $IDENTIFIER[1]="manual"
LOCAL $PARAMETER=STRINGSPLIT($IDENTIFIER[2],",")
GUICTRLSETSTATE($AUTOMANUAL,$PARAMETER[1])
GUICTRLSETDATA($MANUAL_POSX,$PARAMETER[2])
GUICTRLSETDATA($MANUAL_POSY,$PARAMETER[3])
GUICTRLSETDATA($DELAYMANUAL,$PARAMETER[4])
GUICTRLSETDATA($CASTINGMANUAL,$PARAMETER[5])
GUICTRLSETDATA($MANUAL_CONFIRMKEY,$PARAMETER[6])
CASE $IDENTIFIER[1]="1" OR $IDENTIFIER[1]="2" OR $IDENTIFIER[1]="3" OR $IDENTIFIER[1]="4" OR $IDENTIFIER[1]="5" OR $IDENTIFIER[1]="6" OR $IDENTIFIER[1]="7" OR $IDENTIFIER[1]="8" OR $IDENTIFIER[1]="9" OR $IDENTIFIER[1]="0"
LOCAL $PARAMETER=STRINGSPLIT($IDENTIFIER[2],",")
LOCAL $IDX=$IDENTIFIER[1]
IF $IDX=0 THEN
$IDX=10
ENDIF
GUICTRLSETSTATE($ACTIVSKILL[$IDX],$PARAMETER[1])
GUICTRLSETDATA($DELAYSKILL[$IDX],$PARAMETER[2])
GUICTRLSETDATA($CASTINGSKILL[$IDX],$PARAMETER[3])
GUICTRLSETDATA($COOLDOWNSKILL[$IDX],$PARAMETER[4])
CASE $IDENTIFIER[1]="mouseCoordMode"
LOCAL $PARAMETER=STRINGSPLIT($IDENTIFIER[2],",")
IF $PARAMETER[1]=1 THEN
GUICTRLSETSTATE($COORDABS,$GUI_CHECKED)
$MOUSECOORDMODE=1
AUTOITSETOPTION("MouseCoordMode",1)
ELSEIF $PARAMETER[1]=2 THEN
GUICTRLSETSTATE($COORDREL,$GUI_CHECKED)
$MOUSECOORDMODE=2
AUTOITSETOPTION("MouseCoordMode",2)
ENDIF
CASE $IDENTIFIER[1]="<giftScript>"
$GIFTSCRIPTON=TRUE
CASE $IDENTIFIER[1]="</giftScript>"
$GIFTSCRIPTON=FALSE
CASE $GIFTSCRIPTON=TRUE
IF $IDENTIFIER[1]<>"" THEN
GUICTRLSETDATA($GIFTSCRIPT,GUICTRLREAD($GIFTSCRIPT)&STRINGREPLACE($IDENTIFIER[1],@TAB,"")&@CRLF)
ENDIF
ENDSELECT
NEXT
ENDFUNC
FUNC SAVEPRESET()
LOCAL $FILE=FILEOPEN($PRESETFILE,2)
IF $FILE=-1 THEN
MSGBOX(0,"Error","Unable to open file.")
ELSE
FOR $I=1 TO 10
FILEWRITELINE($FILE,$SKILL[$I]&":"&GUICTRLREAD($ACTIVSKILL[$I])&","&GUICTRLREAD($DELAYSKILL[$I])&","&GUICTRLREAD($CASTINGSKILL[$I])&","&GUICTRLREAD($COOLDOWNSKILL[$I]))
NEXT
FILEWRITELINE($FILE,"p"&":"&GUICTRLREAD($ACTIVSKILL[11])&","&GUICTRLREAD($DELAYSKILL[11])&","&GUICTRLREAD($CASTINGSKILL[11]))
FILEWRITELINE($FILE,"space"&":"&GUICTRLREAD($ACTIVSKILL[12])&","&GUICTRLREAD($DELAYSKILL[12]))
FILEWRITELINE($FILE,"a"&":"&GUICTRLREAD($ACTIVSKILL[13])&","&GUICTRLREAD($DELAYSKILL[13]))
FILEWRITELINE($FILE,"special"&":"&GUICTRLREAD($AUTOSPECIAL)&","&GUICTRLREAD($SPECIAL)&","&GUICTRLREAD($DELAYSPECIAL))
FILEWRITELINE($FILE,"mouseL"&":"&GUICTRLREAD($AUTOMOUSEL)&","&GUICTRLREAD($DELAYMOUSEL))
FILEWRITELINE($FILE,"mouseR"&":"&GUICTRLREAD($AUTOMOUSER)&","&GUICTRLREAD($DELAYMOUSER))
FOR $I=1 TO 4
FILEWRITELINE($FILE,"trap"&$I&":"&GUICTRLREAD($AUTOTRAP[$I])&","&GUICTRLREAD($POSX_TRAP[$I])&","&GUICTRLREAD($POSY_TRAP[$I])&","&GUICTRLREAD($DELAYTRAP[$I])&","&GUICTRLREAD($CASTINGTRAP[$I]))
NEXT
FILEWRITELINE($FILE,"explosion"&":"&GUICTRLREAD($AUTOEXPLOSION))
FILEWRITELINE($FILE,"manual"&":"&GUICTRLREAD($AUTOMANUAL)&","&GUICTRLREAD($MANUAL_POSX)&","&GUICTRLREAD($MANUAL_POSY)&","&GUICTRLREAD($DELAYMANUAL)&","&GUICTRLREAD($CASTINGMANUAL)&","&GUICTRLREAD($MANUAL_CONFIRMKEY))
IF GUICTRLREAD($COORDREL)=$GUI_CHECKED THEN
FILEWRITELINE($FILE,"mouseCoordMode:2")
ELSEIF GUICTRLREAD($COORDABS)=$GUI_CHECKED THEN
FILEWRITELINE($FILE,"mouseCoordMode:1")
ELSE
FILEWRITELINE($FILE,"mouseCoordMode:-1")
ENDIF
FILEWRITELINE($FILE,"gift"&":"&GUICTRLREAD($AUTOGIFT)&","&GUICTRLREAD($DELAYGIFT))
FILEWRITELINE($FILE,"<giftScript>")
$ARRAYSCRIPT=STRINGSPLIT(GUICTRLREAD($GIFTSCRIPT),@CRLF)
FOR $I=1 TO UBOUND($ARRAYSCRIPT)-1
IF $ARRAYSCRIPT[$I]<>"" THEN
FILEWRITELINE($FILE,@TAB&$ARRAYSCRIPT[$I])
ENDIF
NEXT
FILEWRITELINE($FILE,"</giftScript>")
FILECLOSE($FILE)
ENDIF
ENDFUNC
FUNC MODE()
IF $MODE=1 THEN
$MODE=2
ELSEIF $MODE=2 THEN
$MODE=1
ENDIF
MODEDISPLAY()
ENDFUNC
FUNC SPACE()
IF (GUICTRLREAD($ACTIVSKILL[12])=$GUI_CHECKED)THEN
GUICTRLSETSTATE($ACTIVSKILL[12],$GUI_UNCHECKED)
ELSEIF (GUICTRLREAD($ACTIVSKILL[12])=$GUI_UNCHECKED)THEN
GUICTRLSETSTATE($ACTIVSKILL[12],$GUI_CHECKED)
ENDIF
MODEDISPLAY()
ENDFUNC
FUNC MODEDISPLAY()
IF $MODE=1 THEN
GUICTRLSETDATA($LABELMODE,"Mode: Send")
ELSEIF $MODE=2 THEN
GUICTRLSETDATA($LABELMODE,"Mode: ControlSend")
ENDIF
ENDFUNC
FUNC READDELAY()
FOR $I=1 TO 10
$DELAYSKILL[$I]=GUICTRLREAD($DELAYSKILL[$I])
NEXT
FOR $I=11 TO 12
$DELAYSKILL[$I]=GUICTRLREAD($DELAYSKILL[$I])*1000
NEXT
$DELAYSKILL[13]=GUICTRLREAD($DELAYSKILL[$I])
ENDFUNC
FUNC SETENABLE($ENABLE_FLAG)
FOR $I=1 TO 10
GUICTRLSETSTATE($DELAYSKILL[$I],$ENABLE_FLAG)
GUICTRLSETSTATE($CASTINGSKILL[$I],$ENABLE_FLAG)
GUICTRLSETSTATE($COOLDOWNSKILL[$I],$ENABLE_FLAG)
GUICTRLSETSTATE($ACTIVSKILL[$I],$ENABLE_FLAG)
NEXT
GUICTRLSETSTATE($CASTINGSKILL[11],$ENABLE_FLAG)
GUICTRLSETSTATE($ACTIVSKILL[11],$ENABLE_FLAG)
FOR $I=11 TO 13
GUICTRLSETSTATE($DELAYSKILL[$I],$ENABLE_FLAG)
NEXT
GUICTRLSETSTATE($BTNLOADPRESET,$ENABLE_FLAG)
GUICTRLSETSTATE($BTNSAVEPRESET,$ENABLE_FLAG)
GUICTRLSETSTATE($SPECIAL,$ENABLE_FLAG)
GUICTRLSETSTATE($DELAYSPECIAL,$ENABLE_FLAG)
GUICTRLSETSTATE($DELAYMOUSEL,$ENABLE_FLAG)
GUICTRLSETSTATE($DELAYMOUSER,$ENABLE_FLAG)
FOR $I=1 TO 4
GUICTRLSETSTATE($AUTOTRAP[$I],$ENABLE_FLAG)
GUICTRLSETSTATE($POSX_TRAP[$I],$ENABLE_FLAG)
GUICTRLSETSTATE($POSY_TRAP[$I],$ENABLE_FLAG)
GUICTRLSETSTATE($DELAYTRAP[$I],$ENABLE_FLAG)
GUICTRLSETSTATE($CASTINGTRAP[$I],$ENABLE_FLAG)
NEXT
GUICTRLSETSTATE($AUTOEXPLOSION,$ENABLE_FLAG)
GUICTRLSETSTATE($DELAYGIFT,$ENABLE_FLAG)
GUICTRLSETSTATE($GIFTSCRIPT,$ENABLE_FLAG)
GUICTRLSETSTATE($MANUAL_POSX,$ENABLE_FLAG)
GUICTRLSETSTATE($MANUAL_POSY,$ENABLE_FLAG)
GUICTRLSETSTATE($DELAYMANUAL,$ENABLE_FLAG)
GUICTRLSETSTATE($CASTINGMANUAL,$ENABLE_FLAG)
GUICTRLSETSTATE($MANUAL_CONFIRMKEY,$ENABLE_FLAG)
GUICTRLSETSTATE($ROARMAPTEXT,$ENABLE_FLAG)
GUICTRLSETSTATE($BREAKROARMAP,$ENABLE_FLAG)
GUICTRLSETSTATE($DELAYROARMAP,$ENABLE_FLAG)
ENDFUNC
FUNC CLEARGUI()
FOR $I=1 TO 10
GUICTRLSETSTATE($ACTIVSKILL[$I],$GUI_UNCHECKED)
GUICTRLSETDATA($DELAYSKILL[$I],"")
GUICTRLSETDATA($CASTINGSKILL[$I],"")
GUICTRLSETDATA($COOLDOWNSKILL[$I],"")
NEXT
GUICTRLSETSTATE($ACTIVSKILL[11],$GUI_UNCHECKED)
GUICTRLSETDATA($DELAYSKILL[11],"")
FOR $I=12 TO 13
GUICTRLSETSTATE($ACTIVSKILL[$I],$GUI_UNCHECKED)
GUICTRLSETDATA($DELAYSKILL[$I],"")
NEXT
GUICTRLSETSTATE($AUTOMOUSEL,$GUI_UNCHECKED)
GUICTRLSETSTATE($AUTOMOUSER,$GUI_UNCHECKED)
GUICTRLSETDATA($DELAYMOUSEL,"")
GUICTRLSETDATA($DELAYMOUSER,"")
GUICTRLSETSTATE($AUTOROARMAP,$GUI_UNCHECKED)
GUICTRLSETSTATE($REPEATROARMAP,$GUI_UNCHECKED)
GUICTRLSETSTATE($AUTOSPECIAL,$GUI_UNCHECKED)
GUICTRLSETDATA($SPECIAL,"")
GUICTRLSETDATA($DELAYSPECIAL,"")
FOR $I=1 TO 4
GUICTRLSETSTATE($AUTOTRAP[$I],$GUI_UNCHECKED)
GUICTRLSETDATA($POSX_TRAP[$I],"")
GUICTRLSETDATA($POSY_TRAP[$I],"")
GUICTRLSETDATA($DELAYTRAP[$I],"")
GUICTRLSETDATA($CASTINGTRAP[$I],"")
NEXT
GUICTRLSETSTATE($AUTOEXPLOSION,$GUI_UNCHECKED)
GUICTRLSETSTATE($AUTOGIFT,$GUI_UNCHECKED)
GUICTRLSETDATA($DELAYGIFT,"")
GUICTRLSETDATA($GIFTSCRIPT,"")
GUICTRLSETSTATE($AUTOMANUAL,$GUI_UNCHECKED)
GUICTRLSETDATA($MANUAL_POSX,"")
GUICTRLSETDATA($MANUAL_POSY,"")
GUICTRLSETDATA($DELAYMANUAL,"")
GUICTRLSETDATA($CASTINGMANUAL,"")
GUICTRLSETDATA($MANUAL_CONFIRMKEY,"")
ENDFUNC
FUNC RESETTIMER()
FOR $I=1 TO 14
$TIMERSKILL[$I]=0
NEXT
$TIMERSPECIAL=-1
$TIMERMANUAL=-1
$TIMERGIFT=-1
ENDFUNC
FUNC START()
IF $MOUSECOORDMODE=-1 THEN
GUICTRLSETSTATE($COORDREL,$GUI_CHECKED)
$MOUSECOORDMODE=2
AUTOITSETOPTION("MouseCoordMode",2)
ENDIF
IF $START=FALSE THEN
$START=TRUE
RESETTIMER()
SORTDELAY()
GUICTRLSETDATA($LABELSTATE,"State: running")
GUICTRLSETDATA($BTNRUNPAUSE,"Pause")
MODEDISPLAY()
SETENABLE($GUI_DISABLE)
ELSE
$START=FALSE
SLEEP(200)
GUICTRLSETDATA($LABELSTATE,"State: pause")
GUICTRLSETDATA($BTNRUNPAUSE,"Run")
GUICTRLSETDATA($TIMELEFTGIFT,"")
GUICTRLSETDATA($TIMELEFTMANUAL,"")
GUICTRLSETDATA($TIMELEFTSPECIAL,"")
SETENABLE($GUI_ENABLE)
ENDIF
ENDFUNC
FUNC QUIT()
IF $TIMERQUIT=0 THEN
$TIMERQUIT=TIMERINIT()
ELSE
$TIMEDIFFQUIT=TIMERDIFF($TIMERQUIT)
IF $TIMEDIFFQUIT>3000 THEN
$TIMERQUIT=0
ELSE
EXIT
ENDIF
ENDIF
ENDFUNC
#EndRegion func
WHILE 1
$MSG=GUIGETMSG()
SELECT
	  CASE $MSG=$GUI_EVENT_CLOSE
	  Case $MSG = $idButton_Close
		 WinSetOnTop($Hwnd_9D, "", $WINDOWS_NOONTOP)
		 _MouseTrap()
		 EXIT
		 ;ExitLoop
	  Case $MSG = $idButton_StartF7
		  F6War()
	  Case $MSG = $idButton_StartF8
		  F7War()
	  Case $MSG = $idButton_StartF9
		  F8War()
	   Case $MSG = $idButton_Train
		  _Training()
	  Case $MSG = $_idButtonRef
			_Refinement()
	  Case $MSG = $idButton_Pause
		 __Exit()
		 _TraingGround(0)



CASE $MSG=$BTNLOADPRESET
$PRESETFILE=FILEOPENDIALOG("Preset Load",@WORKINGDIR&"\","txt (*.txt)",1)
IF @ERROR THEN
MSGBOX(4096,"","No File(s) chosen")
ELSE
LOADPRESET()
ENDIF
CASE $MSG=$BTNSAVEPRESET
$PRESETFILE=FILESAVEDIALOG("Save Preset",@WORKINGDIR&"\","txt (*.txt)",1)
IF @ERROR THEN
MSGBOX(4096,"","Save cancelled.")
ELSE
SAVEPRESET()
ENDIF
CASE $MSG=$BTNRUNPAUSE
START()
CASE $MSG=$BTNHELPSPECIAL
MSGBOX(4096,"","{DEL}: Delete"&@CRLF&"{PRINTSCREEN}: Print Screen"&@CRLF&"{ENTER}: Enter")
CASE $MSG=$COORDREL AND BITAND(GUICTRLREAD($COORDREL),$GUI_CHECKED)=$GUI_CHECKED
$MOUSECOORDMODE=2
AUTOITSETOPTION("MouseCoordMode",2)
CASE $MSG=$COORDABS AND BITAND(GUICTRLREAD($COORDABS),$GUI_CHECKED)=$GUI_CHECKED
$MOUSECOORDMODE=1
AUTOITSETOPTION("MouseCoordMode",1)
CASE $MSG=$GUI_TIMEDISPLAY
IF GUICTRLREAD($GUI_TIMEDISPLAY)=$GUI_CHECKED THEN
$TIMEDISPLAY=TRUE
ELSE
$TIMEDISPLAY=FALSE
SLEEP(200)
GUICTRLSETDATA($TIMELEFTGIFT,"")
GUICTRLSETDATA($TIMELEFTMANUAL,"")
GUICTRLSETDATA($TIMELEFTSPECIAL,"")
ENDIF
CASE $MSG=$BTNHELPMANUAL
MSGBOX(4096,"","x, y: Position of Manual in Bag-Slot 1 (1024x768 Res. is: 250,450)"&@CRLF&"K: confirm Key (Y)"&@CRLF&"relative / absolute: Mouse Coordinate Mode")
ENDSELECT
IF $START=TRUE THEN
#Region A
IF ((GUICTRLREAD($ACTIVSKILL[13])=1)AND (GUICTRLREAD($DELAYSKILL[13])))<>"" THEN
IF $TIMERSKILL[13]=0 THEN
$TIMERSKILL[13]=TIMERINIT()
ELSE
$TIMEDIFFSKILL[13]=TIMERDIFF($TIMERSKILL[13])
IF $TIMEDIFFSKILL[13]>=GUICTRLREAD($DELAYSKILL[13])THEN
IF $MODE=1 THEN
SEND($SKILL[13])
ELSEIF $MODE=2 THEN
CONTROLSEND($HWND,"","",$SKILL[13])
ENDIF
$TIMERSKILL[13]=0
ENDIF
ENDIF
ENDIF
#EndRegion
#Region skill
FOR $I=1 TO 10
IF (($DELAYSORTED[0][$I]=1)AND ($DELAYSORTED[2][$I]<>""))THEN
IF $TIMERSKILL[$I]=0 THEN
$TIMERSKILL[$I]=TIMERINIT()
ELSE
$TIMEDIFFSKILL[$I]=TIMERDIFF($TIMERSKILL[$I])
IF $TIMEDIFFSKILL[$I]>=$DELAYSORTED[2][$I]THEN
IF $MODE=1 THEN
SEND($DELAYSORTED[1][$I])
ELSEIF $MODE=2 THEN
CONTROLSEND($HWND,"","",$DELAYSORTED[1][$I])
ENDIF
SLEEP($DELAYSORTED[3][$I])
SLEEP($DELAYSORTED[4][$I])
$TIMERSKILL[$I]=0
ENDIF
ENDIF
ENDIF
NEXT
#EndRegion
#Region P
IF ((GUICTRLREAD($ACTIVSKILL[11])=1)AND (GUICTRLREAD($DELAYSKILL[11])))<>"" THEN
IF $TIMERSKILL[11]=0 THEN
$TIMERSKILL[11]=TIMERINIT()
ELSE
$TIMEDIFFSKILL[11]=TIMERDIFF($TIMERSKILL[11])
IF $TIMEDIFFSKILL[11]>=GUICTRLREAD($DELAYSKILL[11])*1000 THEN
FOR $I=1 TO 5
IF $MODE=1 THEN
SEND($SKILL[11])
ELSEIF $MODE=2 THEN
CONTROLSEND($HWND,"","",$SKILL[11])
ENDIF
SLEEP(1000)
NEXT
SLEEP(GUICTRLREAD($CASTINGSKILL[11])*1000)
$TIMERSKILL[11]=0
ENDIF
ENDIF
ENDIF
#EndRegion
#Region Space
IF ((GUICTRLREAD($ACTIVSKILL[12])=$GUI_CHECKED)AND (GUICTRLREAD($DELAYSKILL[12])))<>"" THEN
IF $TIMERSKILL[12]=0 THEN
$TIMERSKILL[12]=TIMERINIT()
ELSE
$TIMEDIFFSKILL[12]=TIMERDIFF($TIMERSKILL[12])
IF $TIMEDIFFSKILL[12]>=GUICTRLREAD($DELAYSKILL[12])*1000 THEN
IF $MODE=1 THEN
SEND($SKILL[12])
ELSEIF $MODE=2 THEN
CONTROLSEND($HWND,"","",$SKILL[12])
ENDIF
$TIMERSKILL[12]=0
ENDIF
ENDIF
ENDIF
#EndRegion
#Region Special
IF ((GUICTRLREAD($AUTOSPECIAL)=$GUI_CHECKED)AND (GUICTRLREAD($DELAYSPECIAL)))<>"" THEN
$DO=FALSE
IF $TIMERSPECIAL=0 THEN
$TIMERSPECIAL=TIMERINIT()
ELSEIF $TIMERSPECIAL=-1 THEN
$TIMERSPECIAL=TIMERINIT()
$DO=TRUE
ELSE
$TIMEDIFFSPECIAL=TIMERDIFF($TIMERSPECIAL)
IF $TIMEDIFFSPECIAL>=GUICTRLREAD($DELAYSPECIAL)*1000 THEN
$DO=TRUE
ENDIF
ENDIF
IF $DO=TRUE THEN
IF $MODE=1 THEN
SEND(GUICTRLREAD($SPECIAL))
ELSEIF $MODE=2 THEN
CONTROLSEND($HWND,"","",GUICTRLREAD($SPECIAL))
ENDIF
$TIMERSPECIAL=0
ELSEIF $TIMEDISPLAY=TRUE THEN
GUICTRLSETDATA($TIMELEFTSPECIAL,SEC2TIME(INT((GUICTRLREAD($DELAYSPECIAL)*1000-$TIMEDIFFSPECIAL)/1000),"full"))
ENDIF
ENDIF
#EndRegion
#Region manual
IF (GUICTRLREAD($AUTOMANUAL)=$GUI_CHECKED)THEN
LOCAL $DELAY=GUICTRLREAD($DELAYMANUAL)
LOCAL $DO=FALSE
IF $DELAY=0 THEN
$DELAY=30
ENDIF
IF $TIMERMANUAL=0 THEN
$TIMERMANUAL=TIMERINIT()
ELSEIF $TIMERMANUAL=-1 THEN
$TIMERMANUAL=TIMERINIT()
$DO=TRUE
ELSE
$TIMEDIFFMANUAL=TIMERDIFF($TIMERMANUAL)
IF $TIMEDIFFMANUAL>=$DELAY*60*1000 THEN
$DO=TRUE
ENDIF
ENDIF
IF $DO=TRUE THEN
GUICTRLSETDATA($TIMELEFTMANUAL,"reading ... ")
SLEEP(5000)
IF $MODE=1 THEN
SEND(@TAB)
ELSEIF $MODE=2 THEN
CONTROLSEND($HWND,"","",@TAB)
ENDIF
SLEEP(2000)
MOUSEMOVE(GUICTRLREAD($MANUAL_POSX),GUICTRLREAD($MANUAL_POSY))
SLEEP(2000)
MOUSECLICK("right")
SLEEP(3000)
$CONFIRMKEY=""
IF GUICTRLREAD($MANUAL_CONFIRMKEY)="" THEN
$CONFIRMKEY="Y"
ELSE
$CONFIRMKEY=GUICTRLREAD($MANUAL_CONFIRMKEY)
ENDIF
IF $MODE=1 THEN
SEND($CONFIRMKEY)
ELSEIF $MODE=2 THEN
CONTROLSEND($HWND,"","",$CONFIRMKEY)
ENDIF
SLEEP(GUICTRLREAD($CASTINGMANUAL)*1000)
IF $MODE=1 THEN
SEND(@TAB)
ELSEIF $MODE=2 THEN
CONTROLSEND($HWND,"","",@TAB)
ENDIF
SLEEP(3000)
$TIMERMANUAL=0
GUICTRLSETDATA($TIMELEFTMANUAL,"")
ELSEIF $TIMEDISPLAY=TRUE THEN
GUICTRLSETDATA($TIMELEFTMANUAL,"waiting "&SEC2TIME(INT(($DELAY*60*1000-$TIMEDIFFMANUAL)/1000),"full"))
ENDIF
ENDIF
#EndRegion
#Region MouseL
IF (GUICTRLREAD($AUTOMOUSEL)=$GUI_CHECKED)THEN
LOCAL $DELAY=GUICTRLREAD($DELAYMOUSEL)
IF $DELAY=0 THEN
$DELAY=2
ENDIF
IF $TIMERMOUSEL=0 THEN
$TIMERMOUSEL=TIMERINIT()
ELSE
$TIMEDIFFMOUSEL=TIMERDIFF($TIMERMOUSEL)
IF $TIMEDIFFMOUSEL>=$DELAY*1000 THEN
MOUSEDOWN("left")
SLEEP(200)
MOUSEUP("left")
SLEEP(500)
$TIMERMOUSEL=0
ENDIF
ENDIF
ENDIF
#EndRegion
#Region MouseR
IF (GUICTRLREAD($AUTOMOUSER)=$GUI_CHECKED)THEN
LOCAL $DELAY=GUICTRLREAD($DELAYMOUSER)
IF $DELAY=0 THEN
$DELAY=2
ENDIF
IF $TIMERMOUSER=0 THEN
$TIMERMOUSER=TIMERINIT()
ELSE
$TIMEDIFFMOUSER=TIMERDIFF($TIMERMOUSER)
IF $TIMEDIFFMOUSER>=$DELAY*1000 THEN
MOUSEDOWN("right")
SLEEP(200)
MOUSEUP("right")
SLEEP(500)
$TIMERMOUSER=0
ENDIF
ENDIF
ENDIF
#EndRegion
#Region Trap
FOR $I=1 TO 4
IF (GUICTRLREAD($AUTOTRAP[$I])=$GUI_CHECKED)THEN
LOCAL $DELAY=GUICTRLREAD($DELAYTRAP[$I])
IF $DELAY=0 THEN
$DELAY=20
ENDIF
IF $TIMERTRAP[$I]=0 THEN
$TIMERTRAP[$I]=TIMERINIT()
ELSE
$TIMEDIFFTRAP[$I]=TIMERDIFF($TIMERTRAP[$I])
IF $TIMEDIFFTRAP[$I]>=$DELAY*1000 THEN
IF $MODE=1 THEN
SEND($I)
ELSEIF $MODE=2 THEN
CONTROLSEND($HWND,"","",$I)
ENDIF
SLEEP(1000)
MOUSEMOVE(GUICTRLREAD($POSX_TRAP[$I]),GUICTRLREAD($POSY_TRAP[$I]))
SLEEP(500)
MOUSEDOWN("left")
SLEEP(500)
MOUSEUP("left")
SLEEP(1000)
SLEEP(GUICTRLREAD($CASTINGTRAP[$I])*1000)
$TIMERTRAP[$I]=0
ENDIF
ENDIF
ENDIF
IF (GUICTRLREAD($AUTOEXPLOSION)=$GUI_CHECKED)THEN
IF $MODE=1 THEN
SEND("5")
ELSEIF $MODE=2 THEN
CONTROLSEND($HWND,"","","5")
ENDIF
SLEEP(1000)
ENDIF
NEXT
#EndRegion
#Region RoarMap
IF (GUICTRLREAD($AUTOROARMAP)=$GUI_CHECKED)THEN
LOCAL $DOROARMAP=0
IF GUICTRLREAD($REPEATROARMAP)=$GUI_UNCHECKED THEN
GUICTRLSETSTATE($AUTOROARMAP,$GUI_UNCHECKED)
$DOROARMAP=1
ELSE
IF $TIMERROARMAP=0 THEN
$TIMERROARMAP=TIMERINIT()
ELSE
$TIMEDIFFROARMAP=TIMERDIFF($TIMERROARMAP)
IF $TIMEDIFFROARMAP>=GUICTRLREAD($DELAYROARMAP)*1000 THEN
$DOROARMAP=1
ENDIF
ENDIF
ENDIF
IF $DOROARMAP=1 THEN
LOCAL $BREAK=GUICTRLREAD($BREAKROARMAP)
$ARRAYSTRING=STRINGSPLIT(GUICTRLREAD($ROARMAPTEXT),@CRLF,1)
FOR $I=1 TO $ARRAYSTRING[0]
$ARRAYLINE=STRINGSPLIT($ARRAYSTRING[$I],"",1)
FOR $J=1 TO $ARRAYLINE[0]
IF $MODE=1 THEN
SEND($ARRAYLINE[$J])
ELSEIF $MODE=2 THEN
CONTROLSEND($HWND,"","",$ARRAYLINE[$J])
ENDIF
SLEEP(50)
NEXT
IF $MODE=1 THEN
SEND($ENTER)
ELSEIF $MODE=2 THEN
CONTROLSEND($HWND,"","",$ENTER)
ENDIF
SLEEP($BREAK*1000)
NEXT
$TIMERROARMAP=0
ENDIF
ENDIF
#EndRegion
#Region Gift ver 2
IF GUICTRLREAD($AUTOGIFT)=1 THEN
LOCAL $DELAY=GUICTRLREAD($DELAYGIFT)
LOCAL $DO=FALSE
IF $DELAY=0 THEN
$DELAY=10
ENDIF
IF $TIMERGIFT=0 THEN
$TIMERGIFT=TIMERINIT()
ELSEIF $TIMERGIFT=-1 THEN
$TIMERGIFT=TIMERINIT()
$DO=TRUE
ELSE
$TIMEDIFFGIFT=TIMERDIFF($TIMERGIFT)
IF $TIMEDIFFGIFT>=$DELAY*60*1000 THEN
$DO=TRUE
ENDIF
ENDIF
IF $ERRORGIFT=TRUE THEN
GUICTRLSETDATA($LABELERRGIFT,"error!")
ELSE
GUICTRLSETDATA($LABELERRGIFT,"")
ENDIF
IF $DO THEN
GUICTRLSETDATA($TIMELEFTGIFT,"doing... ")
$ERRORGIFT=FALSE
$ARRAYSCRIPT=STRINGSPLIT(GUICTRLREAD($GIFTSCRIPT),@CRLF)
$RETURNVAL=""
FOR $I=1 TO UBOUND($ARRAYSCRIPT)-1
IF $ARRAYSCRIPT[$I]<>"" THEN
$RETURNVAL=EXECUTE($ARRAYSCRIPT[$I])
IF $RETURNVAL<>1 THEN
$ERRORGIFT=TRUE
ENDIF
ENDIF
NEXT
SLEEP(3000)
$TIMERGIFT=0
GUICTRLSETDATA($TIMELEFTGIFT,"")
ELSEIF $TIMEDISPLAY=TRUE THEN
GUICTRLSETDATA($TIMELEFTGIFT,"waiting "&SEC2TIME(INT(($DELAY*60*1000-$TIMEDIFFGIFT)/1000),"full"))
ENDIF
ENDIF
#EndRegion
ENDIF
WEND

